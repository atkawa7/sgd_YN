<uip>

	<servers>
		<adapter name="JMXUip" apply="uip" implement="com.ztesoft.zsmart.uip.adapters.servers.jmx.JmxAcceptor" comments="JMXServer">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- ip -->
				<ip>127.0.0.1</ip>
				<!-- 端口 -->
				<!-- port -->
				<port>9888</port>
			</params>
			<MBeanList>
				<MBean classFullName="com.ztesoft.zsmart.uip.management.Mbean.impl.UIPManagementMBeanImpl" objectName="management:type=UIPManagement"></MBean>
			</MBeanList>
		</adapter>

		<adapter name="JMXBp" apply="bp" implement="com.ztesoft.zsmart.uip.adapters.servers.jmx.JmxAcceptor" comments="JMXServer">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- ip -->
				<ip>127.0.0.1</ip>
				<!-- 端口 -->
				<!-- port -->
				<port>9889</port>
			</params>
			<MBeanList>
				<MBean classFullName="com.ztesoft.zsmart.uip.management.Mbean.impl.BPManagementMBeanImpl" objectName="management:type=BPManagement"></MBean>
			</MBeanList>
		</adapter>

		<adapter name="BP" apply="bp" comments="MockBPServer">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- ip地址 -->
			    <!-- IP address -->
				<ip>10.45.16.130</ip>
				<!-- ip端口 -->
				<!-- ip port -->
				<port>19999</port>
				<!-- 协议类型 -->
				<!-- The type of protocol -->
				<protocol>Remoting</protocol>
				<!-- -1 则自动获取 -->
				<!-- -1:automatic acquisition -->
				<io-threads>4</io-threads>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>20</msg-threads>
				<!--连接最大空闲时间(s) -->
				<!-- Max idle time -->
				<maxChannelIdleTime>600</maxChannelIdleTime>
				<!--连接空闲检查间隔(s) -->
				<!-- The time interval of idle check -->
				<channelIdleCheckInterval>60</channelIdleCheckInterval>
				<!--写流量文件间隔(s) -->
				<!-- The time interval of write caps file,the unit is second. -->
				<flowStatWriteInterval>1</flowStatWriteInterval>
				<!--写连接文件间隔(s) -->
				<!-- The time interval of write connection file,the unit is second. -->
				<connectionScanInterval>300</connectionScanInterval>
				<!-- 消息日志级别，FULL；详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
				<writeMsgLogLevel>OFF</writeMsgLogLevel>
				<!--最大总流量 -->
				<!-- The maximum total caps -->
				<totalCaps>2000</totalCaps>
				<!--BP业务线程池大小,配置为0为系统自动计算;也可根据环境cpu的核数配置,一般是cpu核数*6 -->
				<!-- The thread size of BP business,0:system automatic calculate; according to the number of nuclei CPU environment configuration, is generally CPU nuclear number *6 -->
				<repositoryThreadSize>0</repositoryThreadSize>
				<!--BP业务队列大小，配置为0为系统自动计算;也可根据环境cpu的核数配置,一般是cpu核数*60-->
				<!-- The size of the bp business queue.0:system automatic calculate; according to the number of nuclei CPU environment configuration, is generally CPU nuclear number *60 -->
				<repositoryQueueSize>0</repositoryQueueSize>
				<!--切包失败超过这个次数，就关闭连接，默认是2，有包头的协议可以调大-->
				<!-- the maximum Split Error Times,the connection will be closed when the num more than maximum,2 by default,the num can be adjusted to a big if protocol has head-->
				<maxSplitErrorTimes>10</maxSplitErrorTimes>
				<!--检查任务队列中是否有超时元素 -->
				<!--check exist timeout element in task queue -->
				<isCheckQueueTimeout>true</isCheckQueueTimeout>
				<!--消息优先级配置 -->
				<!--Message priority configuration -->
				<msgPriority>
					<!--是否使用优先级队列缓存消息,true有效,false无效,因优先级队列会降低队列性能,所以默认为false -->
					<!--Whether to use priority queue cache message,true:Effective,false:Invalid.default:false -->
	                <enablePriorityQueue>false</enablePriorityQueue>
					<!--关键优先级:大于等于此优先级,则认为是高优先级任务.如果没有启用优先级队列,则忽略此配置项-->
					<!--critical Priority,>=criticalPriority,means the high priority task.if the priority queue is false, ignore this Configuration -->
	                <criticalPriority>3</criticalPriority>	               
		            <!--关键优先级队列长度占总长度的比率,值为int,默认是85%,当优先级队列的长度大于等于此长度时,不允许放入低优先级任务,为高优先级任务预留空间.如果没有启用优先级队列,则忽略此配置项-->
	                <!-- A percentage of the total length of the critical Priority,type is int,default:85%.if the length of priority queue>=criticalQueueSizeRatio,forbidden set low priority task.if the priority queue is false, ignore this Configuration-->
				   <criticalQueueSizeRatio>85</criticalQueueSizeRatio>
				</msgPriority>
			</params>
			<!--流量相关参数 -->
			<!-- parameters related to caps -->
			<capsControl>
				<totalCaps name="totalFlow" caps="{totalCaps}:500" ctrlMode="{totalCapsMode}:1"></totalCaps>
			</capsControl>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<!--main pipeline -->
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<!--handler name="handler" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.TelnetServerHandler"/ -->
				</main>
				<!--child pipeline -->
				<child>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="gateway" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.gateway.ChannelGateway">
						<job name="connection-scan" runat="connection-scan" interval="{connectionScanInterval}:300" unit="sec" />
					</handler>
					<handler name="connTimedout" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ConnectionTimeoutHandler">
						<job name="connection-timeout" runat="connection-timeout" interval="{channelIdleCheckInterval}:60" unit="sec" />
					</handler>
					<handler name="loadReporter" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.BPLoadReporter">
						<job name="bp-loadreport-job" runat="bp-load-report" interval="100" unit="millis" />
					</handler>
				</child>
				<!--in pipeline -->
				<in>
					<handler name="readTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ServerSocketOneToOneDecoder" threadPool="{msg-threads}:20" />
					<handler name="bpNbrTracer" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.BPNbrTraceHandler" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="{flowStatWriteInterval}:1" unit="sec" />
					</handler>
					<handler name="repository" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.BPPacketRepository" />
					<handler name="business" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.BusiEngineHandler" />
					<handler name="service" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.ServiceExecutionHandler" />
					<handler name="callBusi" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.RemotingServerCallBusi" />
				</in>
				<!--out pipeline -->
				<out>
					<!-- 优先进行one-way处理   -->
					<!-- Priority do one-way deal -->
					<handler name="oneway" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.OneWayHandler" />
					<!-- BP上用到USSD才需要配置此handler -->
					<!-- USSD is used in BP need this configuration -->
					<handler name="ussd" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.UssdRebind" />
					<handler name="business" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.BusiEngineHandler" />
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway" />
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
				</out>
			</pipeline>

			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
				<thread name="connection-scan" />
				<thread name="heartbeat-scan" />
				<thread name="connection-timeout" />
				<thread name="bp-load-report" />
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>

		<adapter name="Telnet" apply="uip" comments="TelnetServer">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- ip -->
				<ip>127.0.0.1</ip>
				<!-- 端口 -->
				<!-- port -->
				<port>9901</port>
				<!-- -1 则自动获取 -->
			    <!-- -1:automatic acquisition -->
				<io-threads>4</io-threads>
			</params>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<!--main pipeline -->
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="handler" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.TelnetServerHandler" />
				</main>
				<!--child pipeline -->
				<child>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="handler" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.TelnetServerHandler" />
				</child>
				<!--in pipeline -->
				<in>
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.DelimiterBasedFrameDecoder" />
					<handler name="decoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.string.StringDecoder" />
					<handler name="handler" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.TelnetServerHandler" />
				</in>
				<!--out pipeline -->
				<out>
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.string.StringEncoder" />
				</out>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
				<thread name="connection-scan" />
				<thread name="heartbeat-scan" />
				<thread name="connection-timeout" />
			</jobs-threads>
		</adapter>

		<adapter name="VC" apply="uip" comments="VCServer">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- ip地址 -->
				<!-- ip address -->
				<ip>10.45.16.130</ip>
				<!-- ip端口 -->
				<!-- ip port -->
				<port>9007</port>
				<!-- 协议名称 -->
				<!-- protocol name -->
				<protocol>VC</protocol>
				<!-- -1 则自动获取 -->
				<!-- -1:automatic acquisition -->
				<io-threads>4</io-threads>
				<!--最大连接数 -->
				<!-- The maximum of connection -->
				<maxConnections>200</maxConnections>
				<!--客户端ip校验正则表达式 -->
				<!-- client ip check regex -->
				<ipCheckRegex></ipCheckRegex>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>16</msg-threads>
				<!--连接最大空闲时间(s) -->
				<!-- Max idle time -->
				<maxChannelIdleTime>600</maxChannelIdleTime>
				<!--连接空闲检查间隔(s) -->
				<!-- The time interval of idle check -->
				<channelIdleCheckInterval>60</channelIdleCheckInterval>
				<!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
				<heartBeatMode>1</heartBeatMode>
				<!--服务端心跳间隔（s），服务端心跳时有效 -->
				<!-- The time interval of server Activity Hb -->
				<serverActivityHbInterval>50</serverActivityHbInterval>
				<!--服务端心跳不回复最大次数，超过断开连接 -->
				<!-- The maximum of server HB Not Replay ,more than it then disconnect-->
				<maxHBNotReplay>3</maxHBNotReplay>
				<!--写流量文件间隔(s) -->
				<!-- The time interval of write caps file,the unit is second. -->
				<flowStatWriteInterval>1</flowStatWriteInterval>
				<!--写连接文件间隔(s) -->
				<!-- The time interval of write connection file,the unit is second. -->
				<connectionScanInterval>300</connectionScanInterval>
				<!-- 消息日志级别，FULL：详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
				<writeMsgLogLevel>OFF</writeMsgLogLevel>
				<!--最大总流量 -->
				<!-- The maximum of total caps -->
				<totalCaps>500</totalCaps>
				<!--总流量控制方式0：不控制 1：告警 2：告警并回复过载消息 -->
				<!-- Total caps control mode,0: No control,1: alarm,2: alarm and reply overload message -->
				<totalCapsMode>2</totalCapsMode>
			</params>
			<!--流量相关参数 -->
			<!-- parameters related to caps -->
			<capsControl>
				<totalCaps name="totalFlow" caps="{totalCaps}:500" ctrlMode="{totalCapsMode}:1"></totalCaps>
				<busiCaps name="VCQuery" caps="{VCQueryCaps}:100" ctrlMode="1"></busiCaps>
			</capsControl>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<!--main pipeline -->
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
				</main>
				<!--child pipeline -->
				<child>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="gateway" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.gateway.ChannelGateway">
						<job name="connection-scan" runat="connection-scan" interval="{connectionScanInterval}:300" unit="sec" />
					</handler>
				</child>
				<!--in pipeline -->
				<in>
					<handler name="readTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ServerSocketOneToOneDecoder" threadPool="{msg-threads}:20" />
					<handler name="nbrTracer" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.NbrTraceHandler" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="connTimedout" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ActivityValidatingHandler">
						<job name="connection-timeout" runat="connection-timeout" interval="{channelIdleCheckInterval}:60" unit="sec" />
						<job name="server-activity" runat="heartbeat-scan" interval="{serverActivityHbInterval}:50" unit="sec" />
					</handler>
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="{flowStatWriteInterval}:1" unit="sec" />
					</handler>
					<handler name="authentication" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.authentication.PacketAuthentication" />
					<handler name="dispatcher" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.PacketDispatcher" />
					<!--handler name="BPSimulator" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.servers.BPSimulator"/ -->
				</in>
				<!--out pipeline -->
				<out>
					<handler name="authentication" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.authentication.PacketAuthentication" />
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
					</handler>
				</out>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
				<thread name="connection-scan" />
				<thread name="heartbeat-scan" />
				<thread name="connection-timeout" />
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>

		<adapter name="VC_Simulator" apply="uip" comments="VC Simulator,用户名密码为uip">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- ip 地址 -->
				<!-- ip address -->
				<ip>127.0.0.1</ip>
				<!-- ip 端口 -->
				<!-- ip port -->
				<port>9002</port>
				<!-- 协议名称 -->
				<!-- protocol name -->
				<protocol>VC_Client</protocol>
				<!-- -1 则自动获取 -->
				<!-- -1:automatic acquisition -->
				<io-threads>4</io-threads>
				<!--最大连接数 -->
				<!-- The maximum of connection -->
				<maxConnections>200</maxConnections>
				<!--客户端ip校验正则表达式 -->
				<!-- client ip check regex -->
				<ipCheckRegex></ipCheckRegex>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>16</msg-threads>
				<!--连接最大空闲时间(s) -->
				<!-- Max idle time -->
				<maxChannelIdleTime>600</maxChannelIdleTime>
				<!--连接空闲检查间隔(s) -->
				<!-- The time interval of idle check -->
				<channelIdleCheckInterval>60</channelIdleCheckInterval>
				<!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
				<heartBeatMode>1</heartBeatMode>
				<!--服务端心跳间隔（s），服务端心跳时有效 -->
				<!-- The time interval of server Activity Hb -->
				<serverActivityHbInterval>50</serverActivityHbInterval>
				<!--服务端心跳不回复最大次数，超过断开连接 -->
				<!-- The maximum of server HB Not Replay ,more than it then disconnect-->
				<maxHBNotReplay>3</maxHBNotReplay>
				<!--写流量文件间隔(s) -->
				<!-- The time interval of write caps file,the unit is second. -->
				<flowStatWriteInterval>1</flowStatWriteInterval>
				<!--写连接文件间隔(s) -->
				<!-- The time interval of write connection file,the unit is second. -->
				<connectionScanInterval>300</connectionScanInterval>
				<!-- 消息日志级别，FULL；详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
				<writeMsgLogLevel>OFF</writeMsgLogLevel>
				<!--最大总流量 -->
				<!-- The maximum of total caps -->
				<totalCaps>500</totalCaps>
				<!--总流量控制方式0：不控制 1：告警 2：告警并回复过载消息 -->
				<!-- Total caps control mode,0: No control,1: alarm,2: alarm and reply overload message -->
				<totalCapsMode>2</totalCapsMode>
			</params>
			<!--流量相关参数 -->
			<!-- parameters related to caps -->
			<capsControl>
				<totalCaps name="totalFlow" caps="{totalCaps}:500" ctrlMode="{totalCapsMode}:1"></totalCaps>
			</capsControl>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<!--main pipeline -->
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
				</main>
				<!--child pipeline -->
				<child>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="gateway" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.gateway.ChannelGateway">
						<job name="connection-scan" runat="connection-scan" interval="{connectionScanInterval}:300" unit="sec" />
					</handler>
				</child>
				<!--in pipeline -->
				<in>
					<handler name="readTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ServerSocketOneToOneDecoder" threadPool="{msg-threads}:20" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="connTimedout" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ActivityValidatingHandler">
						<job name="connection-timeout" runat="connection-timeout" interval="{channelIdleCheckInterval}:60" unit="sec" />
						<job name="server-activity" runat="heartbeat-scan" interval="{serverActivityHbInterval}:50" unit="sec" />
					</handler>
					<handler name="authentication" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.authentication.PacketAuthentication" />
					<handler name="dispatcher" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.PacketDispatcher" />
				</in>
				<!--out pipeline -->
				<out>
					<handler name="authentication" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.authentication.PacketAuthentication" />
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
				</out>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
				<thread name="connection-scan" />
				<thread name="heartbeat-scan" />
				<thread name="connection-timeout" />
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>

		<adapter name="MML" apply="uip" comments="MMLServer">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- ip地址 -->
				<!-- ip address -->
				<ip>10.45.16.130</ip>
				<!-- ip端口 -->
				<!-- ip port -->
				<port>9008</port>
				<!-- 协议名称 -->
				<!-- protocol name -->
				<protocol>MML</protocol>
				<!-- -1 则自动获取 -->
				<!-- -1:automatic acquisition -->
				<io-threads>4</io-threads>
				<!--最大连接数 -->
				<!-- The maximum of connection -->
				<maxConnections>200</maxConnections>
				<!--客户端ip校验正则表达式 -->
				<!-- client ip check regex -->
				<allowedClients></allowedClients>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>16</msg-threads>
				<!--连接最大空闲时间(s) -->
				<!-- Max idle time -->
				<maxChannelIdleTime>600</maxChannelIdleTime>
				<!--连接空闲检查间隔(s) -->
				<!-- The time interval of idle check -->
				<channelIdleCheckInterval>60</channelIdleCheckInterval>
				<!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
				<heartBeatMode>1</heartBeatMode>
				<!--服务端心跳间隔（s），服务端心跳时有效 -->
				<!-- The time interval of server Activity Hb -->
				<serverActivityHbInterval>50</serverActivityHbInterval>
				<!--服务端心跳不回复最大次数，超过断开连接 -->
				<!-- The maximum of server HB Not Replay ,more than it then disconnect-->
				<maxHBNotReplay>3</maxHBNotReplay>
				<!--写流量文件间隔(s) -->
				<!-- The time interval of write caps file,the unit is second. -->
				<flowStatWriteInterval>1</flowStatWriteInterval>
				<!--写连接文件间隔(s) -->
				<!-- The time interval of write connection file,the unit is second. -->
				<connectionScanInterval>300</connectionScanInterval>
				<!-- 消息日志级别，FULL；详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
				<writeMsgLogLevel>OFF</writeMsgLogLevel>
				<!-- 是否写消息额外日志，不记录消息日志时不生效 -->
				<!-- Whether to write message extend log when writeMsgLogLevel is not OFF -->
				<isWriteMsgExtLog>false</isWriteMsgExtLog>
				<!-- 针对特定指令记录消息日志，不记录消息日志时不生效，格式：指令1;指令2;指令3 指令之间用分号隔开 -->
				<!-- message log filter by commands when writeMsgLogLevel is not OFF, format:command1;command2;command3 separated by ";" between commands -->
				<writeMsgLogCommands></writeMsgLogCommands>
				<!--最大总流量 -->
				<!-- The maximum of total caps -->
				<totalCaps>500</totalCaps>
				<!--总流量控制方式0：不控制 1：告警 2：告警并回复过载消息 -->
				<!-- Total caps control mode,0: No control,1: alarm,2: alarm and reply overload message -->
				<totalCapsMode>2</totalCapsMode>
				<!--切包失败超过这个次数，就关闭连接，默认是2，有包头的协议可以调大-->
				<!-- the maximum Split Error Times,the connection will be closed when the num more than maximum,2 by default,the num can be adjusted to a big if protocol has head-->
				<maxSplitErrorTimes>10</maxSplitErrorTimes>
				<!--mml协议开始标记切包的时候有用到-->
				 <!-- mml protocol begin flag -->
				<mmlBeginFlagStr>`SC`</mmlBeginFlagStr>
				<!-- 支持V62的fep -->
				<!-- support V62 fep -->
                <fepMode>NONE</fepMode>
			</params>
			<!--流量相关参数 -->
			<!-- parameters related to caps -->
			<capsControl>
				<totalCaps name="totalFlow" caps="{totalCaps}:500" ctrlMode="{totalCapsMode}:1"></totalCaps>
				<busiCaps name="MMLQuery" caps="{MMLQueryCaps}:100" ctrlMode="1"></busiCaps>
			</capsControl>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<!--main pipeline -->
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<!--handler name="handler" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.TelnetServerHandler"/ -->
				</main>
				<!--child pipeline -->
				<child>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="gateway" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.gateway.ChannelGateway">
					<job name="connection-scan" runat="connection-scan" interval="{connectionScanInterval}:300" unit="sec" />
					</handler>
				</child>
				<!--in pipeline -->
				<in>
					<handler name="readTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ServerSocketOneToOneDecoder" threadPool="{msg-threads}:20" />
					<handler name="nbrTracer" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.NbrTraceHandler" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="connTimedout" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ActivityValidatingHandler">
						<job name="connection-timeout" runat="connection-timeout" interval="{channelIdleCheckInterval}:5000000" unit="sec" />
						<job name="server-activity" runat="heartbeat-scan" interval="{serverActivityHbInterval}:50" unit="sec" />
					</handler>
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="authentication" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.authentication.MMLPacketAuthentication" />
					<handler name="dispatcher" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.PacketDispatcher" />
				</in>
				<!--out pipeline -->
				<out>
					<handler name="authentication" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.authentication.PacketAuthentication" />
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway" />
				</out>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
				<thread name="connection-scan" />
				<thread name="heartbeat-scan" />
				<thread name="connection-timeout" />
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>

		<adapter name="USSD" apply="uip" comments="USSDServer">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- ip地址 -->
				<!-- IP address -->
				<ip>10.45.16.130</ip>
				<!-- ip端口 -->
				<!-- ip port -->
				<port>9018</port>
				<!-- 协议名称 -->
				<!-- The name of protocol -->
				<protocol>USSD</protocol>
				<!-- -1 则自动获取 -->
				<!-- -1:automatic acquisition -->
				<io-threads>4</io-threads>
				<!--最大连接数 -->
				<!-- The maximum of connection -->
				<maxConnections>200</maxConnections>
				<!--客户端ip校验正则表达式 -->
				<!-- client ip check regex -->
				<ipCheckRegex></ipCheckRegex>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>16</msg-threads>
				<!--连接最大空闲时间(s) -->
				<!-- Max idle time -->
				<maxChannelIdleTime>600</maxChannelIdleTime>
				<!--连接空闲检查间隔(s) -->
				<!-- The time interval of idle check -->
				<channelIdleCheckInterval>60</channelIdleCheckInterval>
				<!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
				<heartBeatMode>2</heartBeatMode>
				<!--服务端心跳不回复最大次数，超过断开连接 -->
				<!-- The maximum of server HB Not Replay ,more than it then disconnect-->
				<maxHBNotReplay>3</maxHBNotReplay>
				<!--写流量文件间隔(s) -->
				<!-- The time interval of write caps file,the unit is second. -->
				<flowStatWriteInterval>1</flowStatWriteInterval>
				<!--写连接文件间隔(s) -->
				<!-- The time interval of write connection file,the unit is second. -->
				<connectionScanInterval>300</connectionScanInterval>
				<!-- 消息日志级别，FULL；详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
				<writeMsgLogLevel>OFF</writeMsgLogLevel>
				<!--最大总流量 -->
				<!-- The maximum of total caps -->
				<totalCaps>500</totalCaps>
				<!--总流量控制方式0：不控制 1：告警 2：告警并回复过载消息 -->
				<!-- Total caps control mode,0: No control,1: alarm,2: alarm and reply overload message -->
				<totalCapsMode>2</totalCapsMode>
				<!--USSD串的编码方案 15（7位编码0x0F）、17（16位编码0x11）、68（8位编码0x44）-->
				<!-- The coding scheme of USSD series -->
				<codeScheme>17</codeScheme>
				<!-- 会话超时时间，单位:秒 -->
			    <!-- The default timeout of session,the unit is second. -->
				<sessionTimeout>60</sessionTimeout>
			</params>
			<!--流量相关参数 -->
			<!-- parameters related to caps -->
			<capsControl>
				<totalCaps name="totalFlow" caps="{totalCaps}:500" ctrlMode="{totalCapsMode}:1"></totalCaps>
			</capsControl>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<!--main pipeline -->
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
				</main>
				<!--child pipeline -->
				<child>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="gateway" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.gateway.ChannelGateway">
						<job name="connection-scan" runat="connection-scan" interval="{connectionScanInterval}:300" unit="sec" />
					</handler>
				</child>
				<!--in pipeline -->
				<in>
					<handler name="readTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ServerSocketOneToOneDecoder" threadPool="{msg-threads}:20" />
					<handler name="nbrTracer" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.NbrTraceHandler" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="connTimedout" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ActivityValidatingHandler">
						<job name="connection-timeout" runat="connection-timeout" interval="{channelIdleCheckInterval}:60" unit="sec" />
						<job name="server-activity" runat="heartbeat-scan" interval="{serverActivityHbInterval}:50" unit="sec" />
					</handler>
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="{flowStatWriteInterval}:1" unit="sec" />
					</handler>
					<handler name="authentication" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.authentication.PacketAuthentication" />
					<handler name="ussd" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.UssdHandler" >
						<job name="session-timeout" runat="session-timeout" interval="60" unit="sec" />
					</handler>
					<handler name="dispatcher" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.PacketDispatcher" />
				</in>
				<!--out pipeline -->
				<out>
					<handler name="authentication" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.authentication.PacketAuthentication" />
					<handler name="ussd" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.UssdHandler" />
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
					</handler>
				</out>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
				<thread name="connection-scan" />
				<thread name="heartbeat-scan" />
				<thread name="connection-timeout" />
				<thread name="flowStat-write" />
				<thread name="session-timeout" />
			</jobs-threads>
		</adapter>

		<adapter name="SmsGatewayDisp" apply="uip" implement="com.ztesoft.zsmart.uip.adapters.servers.socket.RoutingSocketAcceptor" comments="SMPP Server as Gateway Dispather for uip">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>				
				<!-- ip地址 -->
				<!-- IP address -->
				<ip>10.45.16.130</ip>
				<!-- ip端口 -->
				<!-- ip port -->
				<port>9018</port>
				<!-- 协议名称 -->
				<!-- The name of protocol -->
				<protocol>SMPP</protocol>
				<!-- smpp 协议版本, 33 , 34  -->
				<!-- The version of smpp protocol, 33 or 34 -->
				<interface_version>33</interface_version>
				<!-- data_coding与字符集映射关系，没有配置，使用java默认字符集 -->
				<!-- The mapping relationship between data_coding and character set. Using the Java default character set if not configured-->
				<data_coding_mapping>0=SMSC-DEFAULT|1=US-ASCII|2=US-ASCII|3=ISO-8859-1|4=US-ASCII|5=x-JIS0208|6=ISO-8859-5|7=ISO-8859-8|8=UTF-16BE|10=ISO-2022-JP|13=JIS_X0212-1990|14=EUC-KR</data_coding_mapping>
				<!-- 登录用户列表 -->
				<!-- login user,password table -->
				<users>
					<user name="admin" pass="admin*"/>
					<user name="super" pass="repus*"/>
				</users>
				<!-- -1 则自动获取 -->
				<!-- -1:automatic acquisition -->
				<io-threads>4</io-threads>
				<!--最大连接数 -->
				<!-- The maximum of Connections -->
				<maxConnections>200</maxConnections>
				<!--客户端ip校验正则表达式 -->
				<!-- client ip check regex -->
				<ipCheckRegex></ipCheckRegex>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>16</msg-threads>
				<!-- deliver_sm 请求超时间隔，单位毫秒，缺省15000毫秒 -->
				<!-- Request timeout interval, the unit is millisecond and default is 15000 milliseconds -->
				<connectorTimeout>30000</connectorTimeout>
				<!-- deliver_sm 请求缓冲区大小，用于缓存已经发给 Client 但是还没收到响应的请求的缓存, 缺省值 1500-->
				<!-- The size of request cache,use to cache the request which send to client but haven't received the response,1500 by default. -->
				<requestCache>1500</requestCache>
				<!--连接最大空闲时间(s) -->
				<!-- Max idle time -->
				<maxChannelIdleTime>600</maxChannelIdleTime>
				<!--处理短信话单的服务名 -->
				<!-- The service name which to handle short message ticket -->
				<recordService></recordService>
				<!--连接空闲检查间隔(s) -->
				<!-- The time interval of idle check -->
				<channelIdleCheckInterval>60</channelIdleCheckInterval>
				<!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
				<heartBeatMode>1</heartBeatMode>
				<!--服务端心跳不回复最大次数，超过断开连接 -->
				<!-- The maximum of server HB Not Replay ,more than it then disconnect-->
				<maxHBNotReplay>3</maxHBNotReplay>
				<!--写流量文件间隔(s) -->
				<!-- The time interval of write caps file,the unit is second. -->
				<flowStatWriteInterval>1</flowStatWriteInterval>
				<!--写连接文件间隔(s) -->
				<!-- The time interval of write connection file,the unit is second. -->
				<connectionScanInterval>300</connectionScanInterval>
				<!-- 消息日志级别，FULL；详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
				<writeMsgLogLevel>OFF</writeMsgLogLevel>
				<!--最大总流量 -->
				<!-- The maximum of total caps -->
				<totalCaps>500</totalCaps>
				<!--总流量控制方式0：不控制 1：告警 2：告警并回复过载消息 -->
				<!-- Total caps control mode,0: No control,1: alarm,2: alarm and reply overload message -->
				<totalCapsMode>2</totalCapsMode>
			</params>
			<!--流量相关参数 -->
			<!-- parameters related to caps -->
			<capsControl>
				<totalCaps name="totalFlow" caps="{totalCaps}:500" ctrlMode="{totalCapsMode}:1"></totalCaps>
			</capsControl>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<!--main pipeline -->
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
				</main>
				<!--child pipeline -->
				<child>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="gateway" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.gateway.ChannelGateway">
						<job name="connection-scan" runat="connection-scan" interval="{connectionScanInterval}:300" unit="sec" />
					</handler>
				</child>
				<!--in pipeline -->
				<in>
					<handler name="readTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ServerSocketOneToOneDecoder" threadPool="{msg-threads}:20" />
					<handler name="nbrTracer" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.NbrTraceHandler" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="connTimedout" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ActivityValidatingHandler">
						<job name="connection-timeout" runat="connection-timeout" interval="{channelIdleCheckInterval}:60" unit="sec" />
						<job name="server-activity" runat="heartbeat-scan" interval="{serverActivityHbInterval}:50" unit="sec" />
					</handler>
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="{flowStatWriteInterval}:1" unit="sec" />
					</handler>
					<handler name="authentication" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.authentication.PacketAuthenticationSmpp" />
					<handler name="deliverCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.smpp.SmppGateWayDeliverCache"/>
					<handler name="dispatcher" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.PacketDispatcher" />
				</in>
				<!--out pipeline -->
				<out>
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway"/>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="deliverCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.smpp.SmppGateWayDeliverCache"/>
				</out>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
				<thread name="connection-scan" />
				<thread name="heartbeat-scan" />
				<thread name="connection-timeout" />
				<thread name="flowStat-write" />
				<thread name="session-timeout" />
			</jobs-threads>
		</adapter>

		<adapter name="WebService" apply="uip" comments="WebService" implement="com.ztesoft.zsmart.uip.adapters.servers.ws.WebServerAcceptor">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<serverMode>
					<!--0 或者 1:使用 Jetty Server，2:使用 Jetty Https Server， 缺省 1-->
					<!-- 0 or 1: use Jetty Server，2: use Jetty Https Server， 1 by default -->
					<mode>0</mode>
					<!--最大空闲时间，超过这个时间将会强行关闭客户端链接，单位毫秒，mode 为 1、2 时候生效-->
					<!-- Max idle time,the client connection will be closed when the maximum idle time has elapsed,the unit is millisecond, take effect when mode is 1 or 2. -->
					<maxIdleTime>60000</maxIdleTime>
					<!--http 协议处理线程个数，一般小于 CPU 个数，缺省 4，mode 为 1、2 时候生效-->
					<!-- http protocol handle the number of thread,Generally less than the number of CPU，4 by default，take effect when mode is 1 or 2. -->
					<acceptors>4</acceptors>
					<!--http 最多客户端连接等待个数，缺省值 64，mode 为 1、2 时候生效-->
					<!-- The maximum number of waiting client for http connection,64 by default and take effect when mode is 1 or 2. -->
					<acceptorQueueSize>64</acceptorQueueSize>
					<!-- 设置 http 标志服务器资源紧缺的客户端连接个数，超过这个数将快速清理空闲连接，缺省值 5000 -->
					<!-- The  number of the shortage resources of the server client for http connection,More than this number will quickly clean up idle connections,5000 by default. -->
					<lowResourcesConnections>5000</lowResourcesConnections>
					<!-- 设置 http 标志服务器资源紧缺快速清理空闲连接时的连接空闲时间，缺省值 30000 -->
					<!-- The max idle time of the shortage of resources of the server client for http connection,30000 by default. -->
					<lowResourceMaxIdleTime>30000</lowResourceMaxIdleTime>
					<!--在 mode 为 2 时候需要配置，密钥类型-->
					<!-- Specify the key type when mode is 2. -->
					<keystoreType>PKCS12</keystoreType>
					<!--在 mode 为 2 时候需要配置，密钥所在的路径-->
					<!-- Specify the key path when mode is 2. -->
					<keystore>certificates/server.pkcs12</keystore>
					<!--在 mode 为 2 时候需要配置，密钥的密码1，可以为空-->
					<!-- Specify the key's password when mode is 2, nullable. -->
					<password>password</password>
					<!--在 mode 为 2 时候需要配置，密钥的密码2，可以为空-->
					<!-- Specify the key's password when mode is 2, nullable. -->
					<keyPassword>password</keyPassword>
					<!--在 mode 为 2 时候需要配置，证书类型，可以为空，空的时候取 keystoreType 的值-->
					<!-- Specify the certification type when mode is 2，pick up keystoreType's value when null.-->
					<truststoreType>PKCS12</truststoreType>
					<!--在 mode 为 2 时候需要配置，证书所在的路径，可以为空，空的时候取 keystore 的值-->
					<!-- Specify the certification path when mode is 2，pick up keystore's value when null.-->
					<truststore>certificates/server.pkcs12</truststore>
					<!--在 mode 为 2 时候需要配置，证书的密码，可以为空，空的时候取 password 的值-->
					<!-- Specify the certification password when mode is 2，pick up password's value when null.-->
					<trustPassword>password</trustPassword>
				</serverMode>
				<!-- ip -->
				<ip>10.45.16.130</ip>
				<!-- 端口 -->
				<!-- port -->
				<port>8080</port>
				<!-- 协议名 -->
				<!-- protocol name -->
				<protocol>ACCOUNT</protocol>
				<!-- 是否禁用 addressing -->
				<!-- Whether to disable addressing-->
				<disableAddressing>true</disableAddressing>
				<!-- http 协议请求队列长度 -->
				<!--the length of HTTP protocol request queue -->
				<httpRequestQueue>1000</httpRequestQueue>
				<!-- 最大线程个数 -->
				<!-- The maximum of core thread. -->
				<requestCoreThreadPoolSize>32</requestCoreThreadPoolSize>
				<!-- 最大线程个数 -->
				<!-- The maximum of thread. -->
				<requestMaxThreadPoolSize>128</requestMaxThreadPoolSize>
				<!--客户端ip校验正则表达式 -->
				<!-- client ip check regex -->
				<ipCheckRegex></ipCheckRegex>
				<!--写流量文件间隔(s) -->
				<!-- The time interval of write caps file,the unit is second. -->
				<flowStatWriteInterval>1</flowStatWriteInterval>
				<!--写连接文件间隔(s) -->
				<!-- The time interval of write connection file,the unit is second. -->
				<connectionScanInterval>300</connectionScanInterval>
				<!-- 消息日志级别，FULL；详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
				<writeMsgLogLevel>OFF</writeMsgLogLevel>
				<!-- 是否写消息额外日志，不记录消息日志时不生效 -->
				<!-- Whether to write message extend log when writeMsgLogLevel is not OFF -->
				<isWriteMsgExtLog>false</isWriteMsgExtLog>
				<!-- 针对特定指令记录消息日志，不记录消息日志时不生效，格式：指令1;指令2;指令3 指令之间用分号隔开 -->
				<!-- message log filter by commands when writeMsgLogLevel is not OFF, format:command1;command2;command3 separated by ";" between commands -->
				<writeMsgLogCommands></writeMsgLogCommands>
				<!--最大总流量 -->
				<!-- The maximum of total caps -->
				<totalCaps>500</totalCaps>
				<!--总流量控制方式0：不控制 1：告警 2：告警并回复过载消息 -->
				<!-- Total caps control mode,0: No control,1: alarm,2: alarm and reply overload message -->
				<totalCapsMode>2</totalCapsMode>
				<!--web service用户鉴权定义  -->
				<!--web service user auth define  -->
				<userAuth>
					<!-- 是否启用用户身份验证  -->
					<!-- Whether to enable UserAuth -->
					<enableUserAuth>false</enableUserAuth>
					<!-- 用户字段表达式 ,根据此表达式从soap请求中取用户名-->
					<!-- User field expression, According to this expression takes the username from the soap request  -->
					<userFieldExpr>$req.h.AuthHeader.Username</userFieldExpr>
					<!-- 用户密码表达式,根据此表达式从soap请求中取用户名对应的密码   -->
					<!-- User pwd expression, According to this expression takes the pwd of the user from the soap request  -->
					<userPasswordExpr>$req.h.AuthHeader.Password</userPasswordExpr>
					<users>
						<user name="ocs1" password="smart1"/>
						<user name="ocs2" password="smart2"/>
					</users>
				</userAuth>
				<!--消息优先级配置 -->
				<!--Message priority configuration -->
				<msgPriority>
				    <!--是否区分消息优先级,默认为false,不区分 -->
					<!-- Whether to distinguish message priority,default:false -->
				    <enableMsgPriority>false</enableMsgPriority>
				    <!-- 优先级字段 表达式 -->
					<!-- priority field expression -->
				    <priorityFieldExpr>$req.h.AuthHeader.Username</priorityFieldExpr>
				    <!--优先级字段的值到优先级的映射,用逗号分隔,优先级的值必须大于等于1-->
					<!--The priority field value to the priority mapping,split by comma ,the priority value must >=1-->
				    <priorityMap>ocs01=1,ocs02=2</priorityMap>
				</msgPriority>
				 <!-- 用户访问权限定义 -->
				 <!-- User access definition -->
	            <acl>
		             <!-- 是否启用访问控制 ,true启用,false禁用-->
					 <!-- Whether to enable access control, true:enable false:disable-->
		             <enableAcl>false</enableAcl>
		             <!-- 用户字段表达式 ,根据此表达式从soap请求中取用户名-->
					 <!-- User field expression, According to this expression takes the username from the soap request  -->
		             <userFieldExpr>$req.h.AuthHeader.Username</userFieldExpr>
		             <users>
		                <!-- name：用户名，必须是唯一的，否则忽略后面定义的同名用户 
		                      accessAll:用户是否可以访问所有的接口，为假，则必须在commandRes中列出该用户可以访问的接口 -->
					    <!-- name: User name, must unique ,Otherwise ignored later defined users with that name -->
						<!-- accessAll, Whether a user can access all of the interface,if false,must list the interfaces in commandRes the user can access -->
		                <user name="ocs1" accessAll="true">
		                  <commandRes>
		                    <command>webserviceName:operationName1</command>
		                    <command>webserviceName:operationName2</command>
		                  </commandRes>
		                </user>
		                <user name="ocs2" accessAll="false">
		                  <commandRes>
		                    <!-- 列出所有可以访问的指令 -->
							<!-- List all can access instruction -->
		                    <command>webserviceName:operationName1</command>
		                    <command>webserviceName:operationName2</command>
		                  </commandRes>
		                </user>
		              </users>
	             </acl>
				<!-- 用户渠道配置 -->
				<!-- The user channel configuration -->
				<userChannel>
					<!-- 是否将鉴权用户名映射到不同的渠道 ,true启用,false禁用-->
					<!-- Whether to enable authentication user name mapped to different channels,true:enable,false:disable-->
					<enableUserChannel>false</enableUserChannel>
					<!-- 用户字段表达式 ,根据此表达式从soap请求中取用户名-->
					<!-- User field expression, According to this expression takes the username from the soap request  -->
					<userFieldExpr>$req.h.AuthHeader.Username</userFieldExpr>
					<users>
						<user name="ocs1" channelId="1"/>
						<user name="ocs2" channelId="2"/>
					</users>
					<!-- channel到Ip的绑定 -->
					<!-- The binding of Ip to channel -->
					<channelIpBinding enabled="false">
						<!-- ip基于标准正则表达式 -->
					    <!-- ip based on the standard regular expressions -->	
						<binding channelId="1" ip="10.45.4.16" />
						<binding channelId="2" ip="127.0.0.*|10.16.*"  />
						<binding channelId="3" ip="10.45.4.*"  />
					</channelIpBinding>
				</userChannel>
			</params>
			<!--流量相关参数 -->
			<!-- parameters related to caps -->
			<capsControl>
				<totalCaps name="totalFlow" caps="{totalCaps}:500" ctrlMode="{totalCapsMode}:1"></totalCaps>
				<busiCaps name="MMLQuery" caps="{MMLQueryCaps}:100" ctrlMode="1"></busiCaps>
			</capsControl>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<!--main pipeline -->
				<main>
				</main>
				<!--child pipeline -->
				<child>
				</child>
				<!--in pipeline -->
				<in>
					<handler name="ipAuth" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.WsIpAuthHandler" />
					<handler name="userAuth" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.WsUserAuthHandler" />
					<handler name="aclAuth" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.AclAuthHandler" />
					<handler name="msgPriority" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.MsgPriorityHandler" />
					<handler name="channel" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.WsChannelIdHandler" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="dispatcher" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.PacketDispatcher" />
					<!--handler name="BPSimulator" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.servers.BPSimulator"/ -->
				</in>
				<!--out pipeline -->
				<out>
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway" />
				</out>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>

		<adapter name="JettyHttp" apply="uip" comments="JettyHttp" implement="com.ztesoft.zsmart.uip.adapters.servers.http.ws.JettyHttpAcceptor">
			<!--adapter 参数 -->
			<params>
				<serverMode>
					<!-- 0 或者 1:使用 Jetty Server，2:使用 Jetty Https Server， 缺省 1-->
					<!-- 0 or 1: use Jetty Server，2: use Jetty Https Server， 1 by default -->
					<mode>0</mode>
					<!--最大空闲时间，超过这个时间将会强行关闭客户端链接，单位毫秒，mode 为 1、2 时候生效-->
					<!-- Max idle time,the client connection will be closed when the maximum idle time has elapsed,the unit is millisecond, take effect when mode is 1 or 2. -->
					<maxIdleTime>60000</maxIdleTime>
					<!-- http 协议处理线程个数，一般小于 CPU 个数，缺省 4，mode 为 1、2 时候生效-->
					<!-- http protocol handle the number of thread,Generally less than the number of CPU，4 by default，take effect when mode is 1 or 2. -->
					<acceptors>4</acceptors>
					<!-- http 最多客户端连接等待个数，缺省值 64，mode 为 1、2 时候生效-->
					<!-- The maximum number of waiting client for http connection,64 by default and take effect when mode is 1 or 2. -->
					<acceptorQueueSize>64</acceptorQueueSize>
					<!-- 设置 http 标志服务器资源紧缺的客户端连接个数，超过这个数将快速清理空闲连接，缺省值 5000 -->
					<!-- The  number of the shortage resources of the server client for http connection,More than this number will quickly clean up idle connections,5000 by default. -->
					<lowResourcesConnections>5000</lowResourcesConnections>
					<!-- 设置 http 标志服务器资源紧缺快速清理空闲连接时的连接空闲时间，缺省值 30000 -->
					<!-- The max idle time of the shortage of resources of the server client for http connection,30000 by default. -->
					<lowResourceMaxIdleTime>30000</lowResourceMaxIdleTime>
					<!-- 在 mode 为 2 时候需要配置，密钥类型-->
					<!-- Specify the key type when mode is 2. -->
					<keystoreType>PKCS12</keystoreType>
					<!-- 在 mode 为 2 时候需要配置，密钥所在的路径-->
					<!-- Specify the key path when mode is 2. -->
					<keystore>certificates/server.pkcs12</keystore>
					<!-- 在 mode 为 2 时候需要配置，密钥的密码1，可以为空-->
					<!-- Specify the key's password when mode is 2, nullable. -->
					<password>password</password>
					<!-- 在 mode 为 2 时候需要配置，密钥的密码2，可以为空-->
					<!-- Specify the key's password when mode is 2, nullable. -->
					<keyPassword>password</keyPassword>
					<!-- 在 mode 为 2 时候需要配置，证书类型，可以为空，空的时候取 keystoreType 的值-->
					<!-- Specify the certification type when mode is 2，pick up keystoreType's value when null.-->
					<truststoreType>PKCS12</truststoreType>
					<!-- 在 mode 为 2 时候需要配置，证书所在的路径，可以为空，空的时候取 keystore 的值-->
					<!-- Specify the certification path when mode is 2，pick up keystore's value when null.-->
					<truststore>certificates/server.pkcs12</truststore>
					<!-- 在 mode 为 2 时候需要配置，证书的密码，可以为空，空的时候取 password 的值-->
					<!-- Specify the certification password when mode is 2，pick up password's value when null.-->
					<trustPassword>password</trustPassword>
				</serverMode>
				<!-- ip -->
				<ip>10.45.16.130</ip>
				<!-- 端口 -->
				<!-- port -->
				<port>8090</port>
				<!-- 协议名 -->
				<!-- protocol name -->
				<protocol>HttpXml</protocol>
				<!-- 用于xml业务处理的类名 -->
				<!-- xml coder class name -->
				<xmlCoder>com.ztesoft.zsmart.uip.facilities.http.ws.BaseXmlCoder</xmlCoder>
				<!-- 是否禁用 addressing -->
				<!-- Whether to disable addressing-->
				<disableAddressing>true</disableAddressing>
				<!-- http 协议请求队列长度 -->
				<!--the length of HTTP protocol request queue -->
				<httpRequestQueue>1000</httpRequestQueue>
				<!-- 最大线程个数 -->
				<!-- The maximum of core thread. -->
				<requestCoreThreadPoolSize>32</requestCoreThreadPoolSize>
				<!-- 最大线程个数 -->
				<!-- The maximum of thread. -->
				<requestMaxThreadPoolSize>128</requestMaxThreadPoolSize>
				<!--客户端ip校验正则表达式 -->
				<!-- client ip check regex -->
				<ipCheckRegex></ipCheckRegex>
				<!--写流量文件间隔(s) -->
				<!-- The time interval of write caps file,the unit is second. -->
				<flowStatWriteInterval>1</flowStatWriteInterval>
				<!--写连接文件间隔(s) -->
				<!-- The time interval of write connection file,the unit is second. -->
				<connectionScanInterval>300</connectionScanInterval>
				<!-- 消息日志级别，FULL；详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
				<writeMsgLogLevel>OFF</writeMsgLogLevel>
				<!-- 是否写消息额外日志，不记录消息日志时不生效 -->
				<!-- Whether to write message extend log when writeMsgLogLevel is not OFF -->
				<isWriteMsgExtLog>false</isWriteMsgExtLog>
				<!-- 针对特定指令记录消息日志，不记录消息日志时不生效，格式：指令1;指令2;指令3 指令之间用分号隔开 -->
				<!-- message log filter by commands when writeMsgLogLevel is not OFF, format:command1;command2;command3 separated by ";" between commands -->
				<writeMsgLogCommands></writeMsgLogCommands>
				<!-- 最大总流量 -->
				<!-- The maximum of total caps -->
				<totalCaps>500</totalCaps>
				<!-- 总流量控制方式0：不控制 1：告警 2：告警并回复过载消息 -->
				<!-- Total caps control mode,0: No control,1: alarm,2: alarm and reply overload message -->
				<totalCapsMode>2</totalCapsMode>
				<!-- 用户鉴权定义  -->
				<!-- user auth define  -->
				<userAuth>
					<!-- 是否启用用户身份验证  -->
					<!-- Whether to enable UserAuth -->
					<enableUserAuth>false</enableUserAuth>
					<!-- 用户字段表达式 ,根据此表达式从请求中取用户名-->
					<!-- User field expression, According to this expression takes the username from the request  -->
					<userFieldExpr>$req.v.Username</userFieldExpr>
					<!-- 用户密码表达式,根据此表达式从请求中取用户名对应的密码   -->
					<!-- User pwd expression, According to this expression takes the pwd of the user from the request  -->
					<userPasswordExpr>$req.v.Password</userPasswordExpr>
					<users>
						<user name="ocs1" password="smart1"/>
						<user name="ocs2" password="smart2"/>
					</users>
				</userAuth>
				<!-- 消息优先级配置 --> 
				<!--Message priority configuration -->
				<msgPriority>
					<!-- 是否区分消息优先级,默认为false,不区分 -->
					<enableMsgPriority>false</enableMsgPriority>
					<!-- 优先级字段 表达式 -->
					<priorityFieldExpr>$req.h.AuthHeader.Username</priorityFieldExpr>
					<!-- 优先级字段的值到优先级的映射,用逗号分隔,优先级的值必须大于等于1-->
					<priorityMap>ocs01=1,ocs02=2</priorityMap>
				</msgPriority>
				<!-- 用户访问权限定义 -->
				<!-- User access definition -->
				<acl>
					<!-- 是否启用访问控制 ,true启用,false禁用-->
					<!-- Whether to enable access control, true:enable false:disable-->
					<enableAcl>false</enableAcl>
					<!-- 用户字段表达式 ,根据此表达式从soap请求中取用户名-->
					<!-- User field expression, According to this expression takes the username from the soap request  -->
					<userFieldExpr>$req.v.Username</userFieldExpr>
					<users>
						<!-- name：用户名，必须是唯一的，否则忽略后面定义的同名用户 -->
						<!-- accessAll：用户是否可以访问所有的接口，为假，则必须在commandRes中列出该用户可以访问的接口 -->
						<!-- name: User name, must unique ,Otherwise ignored later defined users with that name -->
						<!-- accessAll, Whether a user can access all of the interface,if false,must list the interfaces in commandRes the user can access -->
						<user name="ocs1" accessAll="true">
							<commandRes>
								<command>webserviceName:operationName1</command>
								<command>webserviceName:operationName2</command>
							</commandRes>
						</user>
						<user name="ocs2" accessAll="false">
							<commandRes>
								<!-- 列出所有可以访问的指令 -->
								<!-- List all can access instruction -->
								<command>webserviceName:operationName1</command>
								<command>webserviceName:operationName2</command>
							</commandRes>
						</user>
					</users>
				</acl>
				<!-- 用户渠道配置 -->
				<!-- The user channel configuration -->
				<userChannel>
					<!-- 是否将鉴权用户名映射到不同的渠道 ,true启用,false禁用-->
					<!-- Whether to enable authentication user name mapped to different channels,true:enable,false:disable-->
					<enableUserChannel>false</enableUserChannel>
					<!-- 用户字段表达式 ,根据此表达式从soap请求中取用户名-->
					<!-- User field expression, According to this expression takes the username from the soap request  -->
					<userFieldExpr>$req.v.Username</userFieldExpr>
					<users>
						<user name="ocs1" channelId="1"/>
						<user name="ocs2" channelId="2"/>
					</users>
					<!-- channel到Ip的绑定 -->
					<!-- The binding of Ip to channel -->
					<channelIpBinding enabled="false">
						<!-- ip基于标准正则表达式 -->
					    <!-- ip based on the standard regular expressions -->	
						<binding channelId="1" ip="10.45.4.16" />
						<binding channelId="2" ip="127.0.0.*|10.16.*"  />
						<binding channelId="3" ip="10.45.4.*"  />
					</channelIpBinding>
				</userChannel>
			</params>
			<!-- 流量相关参数 -->
			<capsControl>
				<totalCaps name="totalFlow" caps="{totalCaps}:500" ctrlMode="{totalCapsMode}:1"></totalCaps>
				<busiCaps name="MMLQuery" caps="{MMLQueryCaps}:100" ctrlMode="1"></busiCaps>
			</capsControl>
			<!-- pipline 构建 -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<!--main pipeline -->
				<main>
				</main>
				<!--child pipeline -->
				<child>
				</child>
				<!--in pipeline -->
				<in>
					<handler name="ipAuth" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.WsIpAuthHandler" />
					<handler name="userAuth" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.WsUserAuthHandler" /> 
					<handler name="aclAuth" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.AclAuthHandler" />
					<handler name="msgPriority" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.MsgPriorityHandler" />
					<handler name="channel" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.WsChannelIdHandler" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="dispatcher" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.PacketDispatcher" />
					<!--handler name="BPSimulator" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.servers.BPSimulator"/ -->
				</in>
				<!--out pipeline -->
				<out>
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway" />
				</out>
			</pipeline>
			<!-- 附属线程 -->
			<jobs-threads>
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>

		<adapter name="WebServiceJMS" apply="uip" comments="WebService JMS Provider" implement="com.ztesoft.zsmart.uip.adapters.servers.ws.JmsWebServiceAcceptor">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- Broker 配置 -->
				<!-- Broker configuration -->
				<broker>
					<!-- 是否嵌入 Broker,缺省 true -->
					<!-- Whether to embed into broker,true by default. -->
					<embedded>false</embedded>
					<!-- broker 的名称 -->
					<!-- broker's name -->
					<name>uipWS</name>
					<!-- Broker 的 URI  -->
					<!-- Broker's URI -->
					<uri>tcp://localhost:61616</uri>
					<!-- 是否启用 jmx 监控  -->
					<!-- Whether to enable jmx monitor -->
					<jmx>false</jmx>
					<!-- 是否启用持久化 -->
					<!-- Whether to enable persistence -->
					<persistent>false</persistent>
					<!-- 是否启用跟踪日志 -->
					<!-- Whether to enable trace log -->
					<trace>false</trace>
					<!-- Socket 缓冲区大小 -->
					<!-- Socket Buffer Size -->
					<socketBufferSize>65536</socketBufferSize>
					<!-- 是否启用 TCP keep alive -->
					<!-- Whether to enable TCP keep alive -->
					<keepAlive>false</keepAlive>
					<!-- Socket 超时，单位毫秒 -->
					<!-- Socket Time out,the unit is millisecond -->
					<soTimeout>10000</soTimeout>
					<!-- 是否启用 TCP_NODELAY  -->
					<!-- Whether to enable TCP_NODELAY -->
					<tcpNoDelay>true</tcpNoDelay>
				</broker>
				<receivingQueue>
					<!-- receivingQueue 的 URI  -->
					<!-- the URI of receivingQueue -->
					<uri>tcp://localhost:61616</uri>
					<!-- queue 的名称 -->
					<!-- the name of queue -->
					<queueName>ws.recv</queueName>
					<!-- 是否启用持久化 -->
					<!-- Whether to enable persistence -->
					<persistent>false</persistent>
					<!-- 消息的过期时间 -->
					<!-- The expiration time of the message -->
					<timeToLive>10000</timeToLive>
				</receivingQueue>
				<sendingQueue>
					<!-- 是否启用发送队列，如果不启用则不回复响应，缺省 true -->
					<!-- Whether to enable sender queue,will not reply response when disabled,true by default. -->
					<embedded>true</embedded>
					<!-- sendingQueue 的 URI  -->
					<!-- the URI of sendingQueue -->
					<uri>tcp://localhost:61616</uri>
					<!-- queue 的名称 -->
					<!-- the name of queue -->
					<queueName>ws.send</queueName>
					<!-- 是否启用持久化 -->
					<!-- Whether to enable persistence -->
					<persistent>false</persistent>
					<!-- 消息的过期时间 -->
					<!-- The expiration time of the message -->
					<timeToLive>10000</timeToLive>
				</sendingQueue>
				<!-- 协议名 -->
				<!-- protocol name -->
				<protocol>ACCOUNT</protocol>
				<!-- 消息处理线程个数 -->
				<!-- The number of thread which can be handled. -->
				<threadPoolSize>32</threadPoolSize>
				<!--写流量文件间隔(s) -->
				<!-- The time interval of write caps file,the unit is second. -->
				<flowStatWriteInterval>1</flowStatWriteInterval>
				<!--写连接文件间隔(s) -->
				<!-- The time interval of write connection file,the unit is second. -->
				<connectionScanInterval>300</connectionScanInterval>
				<!-- 消息日志级别，FULL；详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
				<writeMsgLogLevel>OFF</writeMsgLogLevel>
				<!--最大总流量 -->
				<!-- The maximum of total caps -->
				<totalCaps>500</totalCaps>
				<!--总流量控制方式0：不控制 1：告警 2：告警并回复过载消息 -->
				<!-- Total caps control mode,0: No control,1: alarm,2: alarm and reply overload message -->
				<totalCapsMode>2</totalCapsMode>
			</params>
			<!--流量相关参数 -->
			<!-- parameters related to caps -->
			<capsControl>
				<totalCaps name="totalFlow" caps="{totalCaps}:500" ctrlMode="{totalCapsMode}:1"></totalCaps>
				<busiCaps name="MMLQuery" caps="{MMLQueryCaps}:100" ctrlMode="1"></busiCaps>
			</capsControl>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<!--main pipeline -->
				<main>
				</main>
				<!--child pipeline -->
				<child>
				</child>
				<!--in pipeline -->
				<in>
					<handler name="nbrTracer" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.NbrTraceHandler" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="dispatcher" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.PacketDispatcher" />
					<!--handler name="BPSimulator" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.servers.BPSimulator"/ -->
				</in>
				<!--out pipeline -->
				<out>
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway" />
				</out>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>

		<adapter name="JMSServer" apply="uip" comments="JMS Provider" implement="com.ztesoft.zsmart.uip.adapters.servers.ws.JMSServer">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- Broker 配置 -->
				<!-- Broker configuration -->
				<broker>
					<!-- 是否嵌入 Broker,缺省 true -->
					<!-- Whether to embed into broker,true by default. -->
					<embedded>false</embedded>
					<!-- broker 的名称 -->
					<!-- broker's name -->
					<name>uipWS</name>
					<!-- Broker 的 URI  -->
					<!-- Broker's URI -->
					<uri><!--tcp://localhost:61616?transport.trace=false&transport.soTimeout=10000--></uri>
					<!-- 是否启用 jmx 监控  -->
					<!-- Whether to enable jmx monitor -->
					<jmx>false</jmx>
					<!-- 是否启用持久化 -->
					<!-- Whether to enable persistence -->
					<persistent>false</persistent>
				</broker>
				<receivingQueue>
					<!-- 使用 queue 还是 topic 方式，1:queue, 2:topic, 缺省 1 -->
					<!-- Whether to use queue or topic,1:queue, 2:topic, 1 by default. -->
					<queueMode>1</queueMode>
					<!-- 登录用户名 -->
					<!-- login user name -->
					<userName>zte</userName>
					<!-- 登录密码 -->
					<!-- login user pwd -->
					<password>zte</password>
					<!-- receivingQueue 的 URI，如果使用 hornetq，需要配置为 ip:port 格式，如 127.0.0.1:5445   -->
					<!-- The URI of receivingQueue,need to be configured to IP: port format when use hornetq. for example,127.0.0.1:5445 -->
					<uri>tcp://localhost:61616</uri>
					<!-- queue 的名称 -->
					<!-- Queue's name -->
					<queueName>ws.recv</queueName>
					<!-- 是否启用事务 -->
					<!-- Whether to enable transaction. -->
					<transacted>false</transacted>
					<!-- 是否持久化，缺省 true, queueMode=2 时候需要配置 -->
					<!-- Whether to enable persistence,true by default,need to be configured while queueMode=2 -->
					<persistent>true</persistent>
					<!-- clientId, queueMode=2 时候需要配置 -->
					<!-- clientId,need to be configured while queueMode=2 -->
					<clientId>ztecms</clientId>
					<!-- subscriberId, queueMode=2 时候需要配置 -->
					<!-- subscriberId,need to be configured while queueMode=2 -->
					<subscriberId>subscriber-</subscriberId>
				</receivingQueue>
				<sendingQueue>
					<!-- 使用 topic 还是 queue 方式，1:queue, 2:topic,缺省 1 -->
					<!-- Whether to use queue or topic,1:queue, 2:topic, 1 by default. -->
					<queueMode>1</queueMode>
					<!-- 是否启用发送队列，如果不启用则不回复响应，缺省 true -->
					<!-- Whether to enable sender queue,will not reply response when disabled,true by default. -->
					<enabled>true</enabled>
					<!-- 登录用户名 -->
					<!-- login user name -->
					<userName></userName>
					<!-- 登录密码 -->
					<!-- login user pwd -->
					<password></password>
					<!-- sendingQueue 的 URI  -->
					<!-- The URI of sendingQueue -->
					<uri>tcp://localhost:61616</uri>
					<!-- queue 的名称 -->
					<!-- Queue's name -->
					<queueName>ws.send</queueName>
					<!-- 是否启用持久化 -->
					<!-- Whether to enable persistence -->
					<persistent>false</persistent>
					<!-- 消息的过期时间 -->
					<!-- expire time of the message -->
					<timeToLive>60000</timeToLive>
					<!-- 是否启用事务 -->
					<!-- Whether to enable transaction. -->
					<transacted>false</transacted>
				</sendingQueue>
				<!-- 协议名 -->
				<!-- protocol name -->
				<protocol>ACCOUNT</protocol>
				<!-- 消息处理线程个数 -->
				<!-- The number of thread which can be handled. -->
				<threadPoolSize>32</threadPoolSize>
				<!--写流量文件间隔(s) -->
				<!-- The time interval of write caps file,the unit is second. -->
				<flowStatWriteInterval>1</flowStatWriteInterval>
				<!--写连接文件间隔(s) -->
				<!-- The time interval of write connection file,the unit is second. -->
				<connectionScanInterval>300</connectionScanInterval>
				<!-- 消息日志级别，FULL；详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
				<writeMsgLogLevel>OFF</writeMsgLogLevel>
				<!--每秒钟收取请求的速度 -->
				<!-- The total caps of obtained request in a second. -->
				<totalCaps>50</totalCaps>
				<!--总流量控制方式0：不控制 1：告警 2：告警并回复过载消息 -->
				<!-- Total caps control mode,0: No control,1: alarm,2: alarm and reply overload message -->
				<totalCapsMode>0</totalCapsMode>
			</params>
			<!--流量相关参数 -->
			<!-- parameters related to caps -->
			<capsControl>
				<totalCaps name="totalFlow" caps="{totalCaps}:500" ctrlMode="{totalCapsMode}:1"></totalCaps>
				<busiCaps name="MMLQuery" caps="{MMLQueryCaps}:100" ctrlMode="1"></busiCaps>
			</capsControl>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<!--main pipeline -->
				<main>
				</main>
				<!--child pipeline -->
				<child>
				</child>
				<!--in pipeline -->
				<in>
					<handler name="nbrTracer" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.NbrTraceHandler" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="dispatcher" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.PacketDispatcher" />
					<!--handler name="BPSimulator" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.servers.BPSimulator"/ -->
				</in>
				<!--out pipeline -->
				<out>
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway" />
				</out>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>

		<adapter name="HTTP" apply="uip" comments="HTTPServer">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- 协议名称 -->
				<!-- The name of protocol -->
				<protocol>HttpBinary</protocol>
				<!-- http 服务器地址 -->
				<!--  The IP address of http server -->
				<ip>127.0.0.1</ip>
				<!-- 渠道标记  -->
				<!-- channel Id -->
				<channelId></channelId>
				<!-- http 服务器端口 -->
				<!--  The port of http server -->
				<port>8099</port>
				<!-- -1 则自动获取 -->
				<!-- -1:automatic acquisition -->
				<io-threads>32</io-threads>
				<!--最大连接数 -->
				<!-- The maximum of Connections -->
				<maxConnections>200</maxConnections>
				<!--客户端ip校验正则表达式 -->
				<!-- client ip check regex -->
				<ipCheckRegex></ipCheckRegex>
				<!--连接最大空闲时间(s) -->
				<!-- Max idle time -->
				<maxChannelIdleTime>600</maxChannelIdleTime>
				<!--连接空闲检查间隔(s) -->
				<!-- The time interval of idle check -->
				<channelIdleCheckInterval>60</channelIdleCheckInterval>
				<!--写流量文件间隔(s) -->
				<!-- The time interval of write caps file,the unit is second. -->
				<flowStatWriteInterval>1</flowStatWriteInterval>
				<!--写连接文件间隔(s) -->
				<!-- The time interval of write connection file,the unit is second. -->
				<connectionScanInterval>5000</connectionScanInterval>
				<!-- 消息日志级别，FULL；详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
				<writeMsgLogLevel>OFF</writeMsgLogLevel>
				<!--最大总流量 -->
				<!-- The maximum of total caps -->
				<totalCaps>500</totalCaps>
				<!--总流量控制方式0：不控制 1：告警 2：告警并回复过载消息 -->
				<!-- Total caps control mode,0: No control,1: alarm,2: alarm and reply overload message -->
				<totalCapsMode>2</totalCapsMode>
				<!--切包失败超过这个次数，就关闭连接，默认是2，有包头的协议可以调大-->
				<!-- the maximum Split Error Times,the connection will be closed when the num more than maximum,2 by default,the num can be adjusted to a big if protocol has head-->
				<maxSplitErrorTimes>10</maxSplitErrorTimes>
			</params>
			<!--流量相关参数 -->
			<!-- parameters related to caps -->
			<capsControl>
				<totalCaps name="totalFlow" caps="{totalCaps}:500" ctrlMode="{totalCapsMode}:1"></totalCaps>
			</capsControl>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<!--main pipeline -->
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
				</main>
				<!--child pipeline -->
				<child>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="gateway" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.gateway.ChannelGateway">
					<job name="connection-scan" runat="connection-scan" interval="{connectionScanInterval}:300" unit="sec" />
					</handler>
				</child>
				<!--in pipeline -->
				<in>
					<handler name="readTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="httpDecoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.http.HttpRequestDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.http.HttpServerDecoder" />
					<!--handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.http.HttpRequestHandler"/ -->
					<handler name="channel" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.ChannelIdHandler" />
					<handler name="nbrTracer" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.NbrTraceHandler" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="connTimedout" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ActivityValidatingHandler">
						<job name="connection-timeout" runat="connection-timeout" interval="{channelIdleCheckInterval}:5000000" unit="sec" />
					</handler>
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<!-- handler name="authentication" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.authentication.PacketAuthentication" / -->
					<handler name="dispatcher" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.PacketDispatcher" />
				</in>
				<!--out pipeline -->
				<out>
					<!-- handler name="authentication" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.authentication.PacketAuthentication" / -->
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.http.HttpServerEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway" />
					<handler name="httpEncoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.http.HttpResponseEncoder" />
				</out>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
				<thread name="connection-scan" />
				<thread name="connection-timeout" />
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>

		<adapter name="WINTCP" apply="uip" comments="WinTcpServer">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- ip地址 -->
				<!-- IP address -->
				<ip>10.45.16.130</ip>
				<!-- ip端口 -->
				<!-- ip port -->
				<port>9010</port>
				<!-- 协议名称 -->
				<!-- The name of protocol -->
				<protocol>WINTCP</protocol>
				<!-- -1 则自动获取 -->
				<!-- -1:automatic acquisition -->
				<io-threads>4</io-threads>
				<!--最大连接数 -->
				<!-- The maximum of Connections -->
				<maxConnections>200</maxConnections>
				<!--客户端ip校验正则表达式 -->
				<!-- client ip check regex -->
				<ipCheckRegex></ipCheckRegex>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>16</msg-threads>
				<!--连接最大空闲时间(s) -->
				<!-- Max idle time -->
				<maxChannelIdleTime>600</maxChannelIdleTime>
				<!--连接空闲检查间隔(s) -->
				<!-- The time interval of idle check -->
				<channelIdleCheckInterval>60</channelIdleCheckInterval>
				<!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
				<heartBeatMode>1</heartBeatMode>
				<!--服务端心跳间隔（s），服务端心跳时有效 -->
				<!-- The time interval of server Activity Hb -->
				<serverActivityHbInterval>50</serverActivityHbInterval>
				<!--服务端心跳不回复最大次数，超过断开连接 -->
				<!-- The maximum of server HB Not Replay ,more than it then disconnect-->
				<maxHBNotReplay>3</maxHBNotReplay>
				<!--写流量文件间隔(s) -->
				<!-- The time interval of write caps file,the unit is second. -->
				<flowStatWriteInterval>1</flowStatWriteInterval>
				<!--写连接文件间隔(s) -->
				<!-- The time interval of write connection file,the unit is second. -->
				<connectionScanInterval>300</connectionScanInterval>
				<!-- 消息日志级别，FULL；详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
				<writeMsgLogLevel>OFF</writeMsgLogLevel>
				<!--最大总流量 -->
				<!-- The maximum of total caps -->
				<totalCaps>500</totalCaps>
				<!--总流量控制方式0：不控制 1：告警 2：告警并回复过载消息 -->
				<!-- Total caps control mode,0: No control,1: alarm,2: alarm and reply overload message -->
				<totalCapsMode>2</totalCapsMode>
			</params>
			<!--流量相关参数 -->
			<!-- parameters related to caps -->
			<capsControl>
				<totalCaps name="totalFlow" caps="{totalCaps}:500" ctrlMode="{totalCapsMode}:1"></totalCaps>
			</capsControl>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<!--main pipeline -->
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<!--handler name="handler" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.TelnetServerHandler"/ -->
				</main>
				<!--child pipeline -->
				<child>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="gateway" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.gateway.ChannelGateway">
						<job name="connection-scan" runat="connection-scan" interval="{connectionScanInterval}:300" unit="sec" />
					</handler>
				</child>
				<!--in pipeline -->
				<in>
					<handler name="readTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ServerSocketOneToOneDecoder" threadPool="{msg-threads}:20"/>
					<handler name="nbrTracer" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.NbrTraceHandler" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="connTimedout" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ActivityValidatingHandler">
						<job name="connection-timeout" runat="connection-timeout" interval="{channelIdleCheckInterval}:5000000" unit="sec" />
						<job name="server-activity" runat="heartbeat-scan" interval="{serverActivityHbInterval}:50" unit="sec" />
					</handler>
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="authentication" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.authentication.PacketAuthentication" />
					<handler name="business" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.BusiEngineHandler" />
					<handler name="dispatcher" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.PacketDispatcher" />
					<!--handler name="BPSimulator" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.servers.BPSimulator"/ -->
				</in>
				<!--out pipeline -->
				<out>
					<handler name="business" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.BusiEngineHandler" />
					<handler name="authentication" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.authentication.PacketAuthentication" />
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
					</handler>
				</out>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
				<thread name="connection-scan" />
				<thread name="heartbeat-scan" />
				<thread name="connection-timeout" />
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>

		<adapter name="Remoting" apply="uip" comments="RemotingServer in uip">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- ip地址 -->
				<!-- IP address -->
				<ip>10.45.16.130</ip>
				<!-- ip端口 -->
				<!-- ip port -->
				<port>19980</port>
				<!-- 协议名称 -->
				<!-- The name of protocol -->
				<protocol>Remoting</protocol>
				<!-- -1 则自动获取 -->
				<!-- -1:automatic acquisition -->
				<io-threads>4</io-threads>
				<!--最大连接数 -->
				<!-- The maximum of Connections -->
				<maxConnections>200</maxConnections>
				<!--客户端ip校验正则表达式 -->
				<!-- client ip check regex -->
				<ipCheckRegex></ipCheckRegex>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>16</msg-threads>
				<!--连接最大空闲时间(s) -->
				<!-- Max idle time -->
				<maxChannelIdleTime>600</maxChannelIdleTime>
				<!--连接空闲检查间隔(s) -->
				<!-- The time interval of idle check -->
				<channelIdleCheckInterval>60</channelIdleCheckInterval>
				<!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
				<heartBeatMode>1</heartBeatMode>
				<!--服务端心跳间隔（s），服务端心跳时有效 -->
				<!-- The time interval of server Activity Hb -->
				<serverActivityHbInterval>50</serverActivityHbInterval>
				<!--服务端心跳不回复最大次数，超过断开连接 -->
				<!-- The maximum of server HB Not Replay ,more than it then disconnect-->
				<maxHBNotReplay>3</maxHBNotReplay>
				<!--写流量文件间隔(s) -->
				<!-- The time interval of write caps file,the unit is second. -->
				<flowStatWriteInterval>1</flowStatWriteInterval>
				<!--写连接文件间隔(s) -->
				<!-- The time interval of write connection file,the unit is second. -->
				<connectionScanInterval>30</connectionScanInterval>
				<!-- 消息日志级别，FULL；详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
				<writeMsgLogLevel>OFF</writeMsgLogLevel>
				<!--切包失败超过这个次数，就关闭连接，默认是2，有包头的协议可以调大-->
				<!-- the maximum Split Error Times,the connection will be closed when the num more than maximum,2 by default,the num can be adjusted to a big if protocol has head-->
				<maxSplitErrorTimes>10</maxSplitErrorTimes>			
			</params>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<!--main pipeline -->
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
				</main>
				<!--child pipeline -->
				<child>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="gateway" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.gateway.ChannelGateway">
						<job name="connection-scan" runat="connection-scan" interval="{connectionScanInterval}:30" unit="sec" />
					</handler>
					<handler name="connTimedout" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ConnectionTimeoutHandler">
						<job name="connection-timeout" runat="connection-timeout" interval="5000000" unit="sec" />
					</handler>
				</child>
				<!--in pipeline -->
				<in>
					<handler name="readTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ServerSocketOneToOneDecoder" threadPool="{msg-threads}:20"/>
					<handler name="nbrTracer" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.NbrTraceHandler" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway" >
						<job name="flowStat-write" runat="flowStat-write" interval="{flowStatWriteInterval}:1" unit="sec" />
					</handler>
					<handler name="dispatcher" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.ForwardtoConnector" />
				</in>
				<!--out pipeline -->
				<out>
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
				</out>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
				<thread name="connection-scan" />
				<thread name="heartbeat-scan" />
				<thread name="connection-timeout" />
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>

		<adapter name="RemotingBusiServer" apply="remoting" comments="RemotingServer in other app , not in uip">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- ip地址 -->
				<!-- IP address -->
				<ip>10.45.16.130</ip>
				<!-- ip端口 -->
				<!-- ip port -->
				<port>9660</port>
				<!-- 协议名称 -->
				<!-- The name of protocol -->
				<protocol>Remoting</protocol>
				<!-- -1 则自动获取 -->
				<!-- -1:automatic acquisition -->
				<io-threads>4</io-threads>
				<!--最大连接数 -->
				<!-- The maximum of Connections -->
				<maxConnections>200</maxConnections>
				<!--客户端ip校验正则表达式 -->
				<!-- client ip check regex -->
				<ipCheckRegex></ipCheckRegex>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>16</msg-threads>
				<!--消息存储线程池大小 -->
				<!-- The size of message storage thread pool-->
				<repositoryThreadSize>24</repositoryThreadSize>
				<!--消息存储队列大小 -->
				<!-- The size of message storage queue-->
				<repositoryQueueSize>100</repositoryQueueSize>
				<!--连接最大空闲时间(s) -->
				<!-- Max idle time -->
				<maxChannelIdleTime>600</maxChannelIdleTime>
				<!--连接空闲检查间隔(s) -->
				<!-- The time interval of idle check -->
				<channelIdleCheckInterval>60</channelIdleCheckInterval>
				<!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
				<heartBeatMode>1</heartBeatMode>
				<!--服务端心跳间隔（s），服务端心跳时有效 -->
				<!-- The time interval of server Activity Hb -->
				<serverActivityHbInterval>50</serverActivityHbInterval>
				<!--服务端心跳不回复最大次数，超过断开连接 -->
				<!-- The maximum of server HB Not Replay ,more than it then disconnect-->
				<maxHBNotReplay>3</maxHBNotReplay>
				<!--写流量文件间隔(s) -->
				<!-- The time interval of write caps file,the unit is second. -->
				<flowStatWriteInterval>1</flowStatWriteInterval>
				<!--写连接文件间隔(s) -->
				<!-- The time interval of write connection file,the unit is second. -->
				<connectionScanInterval>300</connectionScanInterval>
				<!-- 消息日志级别，FULL；详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
				<writeMsgLogLevel>OFF</writeMsgLogLevel>
				<!--切包失败超过这个次数，就关闭连接，默认是2，有包头的协议可以调大-->
				<!-- the maximum Split Error Times,the connection will be closed when the num more than maximum,2 by default,the num can be adjusted to a big if protocol has head-->
				<maxSplitErrorTimes>10</maxSplitErrorTimes>				
			</params>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<!--main pipeline -->
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
				</main>
				<!--child pipeline -->
				<child>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="gateway" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.gateway.ChannelGateway">
						<job name="connection-scan" runat="connection-scan" interval="{connectionScanInterval}:300" unit="sec" />
					</handler>
					<handler name="connTimedout" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ConnectionTimeoutHandler">
						<job name="connection-timeout" runat="connection-timeout" interval="5000000" unit="sec" />
					</handler>
				</child>
				<!--in pipeline -->
				<in>
					<handler name="readTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ServerSocketOneToOneDecoder" />
					<handler name="nbrTracer" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.NbrTraceHandler" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway" />
					<handler name="repository" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.PacketRepository" />
					<handler name="callBusi" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.RemotingServerCallBusi" />
				</in>
				<!--out pipeline -->
				<out>
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
				</out>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
				<thread name="connection-scan" />
				<thread name="heartbeat-scan" />
				<thread name="connection-timeout" />
			</jobs-threads>
		</adapter>

		<adapter name="IBMStreamRemoting" apply="uip" comments="用于接收 IBM Stream 的请求">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- ip地址 -->
				<!-- IP address -->
				<ip>127.0.0.1</ip>
				<!-- 端口 -->
				<!-- port -->
				<port>9913</port>
				<!-- 协议类型 -->
				<!-- The type of protocol -->
				<protocol>IBMStreamRemoting</protocol>
				<!-- -1 则自动获取 -->
				<!-- -1:automatic acquisition -->
				<io-threads>4</io-threads>
				<!--最大连接数 -->
				<!-- The maximum of Connections -->
				<maxConnections>200</maxConnections>
				<!--客户端ip校验正则表达式 -->
				<!-- client ip check regex -->
				<ipCheckRegex></ipCheckRegex>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>16</msg-threads>
				<!--连接最大空闲时间(s) -->
				<!-- Max idle time -->
				<maxChannelIdleTime>0</maxChannelIdleTime>
				<!--连接空闲检查间隔(s) -->
				<!-- The time interval of idle check -->
				<channelIdleCheckInterval>60</channelIdleCheckInterval>
				<!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
				<heartBeatMode>2</heartBeatMode>
				<!--写流量文件间隔(s) -->
				<!-- The time interval of write caps file,the unit is second. -->
				<flowStatWriteInterval>1</flowStatWriteInterval>
				<!--写连接文件间隔(s) -->
				<!-- The time interval of write connection file,the unit is second. -->
				<connectionScanInterval>300</connectionScanInterval>
				<!-- 消息日志级别，FULL；详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
				<writeMsgLogLevel>OFF</writeMsgLogLevel>
				<!--最大总流量 -->
				<!-- The maximum of total caps -->
				<totalCaps>500</totalCaps>
				<!--总流量控制方式0：不控制 1：告警 2：告警并回复过载消息 -->
				<!-- Total caps control mode,0: No control,1: alarm,2: alarm and reply overload message -->
				<totalCapsMode>0</totalCapsMode>
			</params>
			<!--流量相关参数 -->
			<!-- parameters related to caps -->
			<capsControl>
				<totalCaps name="totalFlow" caps="{totalCaps}:500" ctrlMode="{totalCapsMode}:1"></totalCaps>
			</capsControl>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<!--main pipeline -->
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
				</main>
				<!--child pipeline -->
				<child>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="gateway" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.gateway.ChannelGateway">
						<job name="connection-scan" runat="connection-scan" interval="{connectionScanInterval}:300" unit="sec" />
					</handler>
				</child>
				<!--in pipeline -->
				<in>
					<handler name="readTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ServerSocketOneToOneDecoder" threadPool="{msg-threads}:20" />
					<handler name="oneway" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.OneWayHandler" />
					<handler name="nbrTracer" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.NbrTraceHandler" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="connTimedout" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ActivityValidatingHandler">
						<job name="connection-timeout" runat="connection-timeout" interval="{channelIdleCheckInterval}:60" unit="sec" />
						<job name="server-activity" runat="heartbeat-scan" interval="{serverActivityHbInterval}:50" unit="sec" />
					</handler>
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="{flowStatWriteInterval}:1" unit="sec" />
					</handler>
					<handler name="dispatcher" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.PacketDispatcher" />
				</in>
				<!--out pipeline -->
				<out>
				</out>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
				<thread name="connection-scan" />
				<thread name="heartbeat-scan" />
				<thread name="connection-timeout" />
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>
		
        <adapter name="DODActionRemotingServer" apply="uip" comments="用于MCCM解决方案中,DOD产品与UIP的接口">
            <!--adapter 参数 -->
			<!--adapter parameters -->
            <params>
                <!-- ip地址 -->
				<!-- IP address -->
                <ip>127.0.0.1</ip>
                <!-- 端口 -->
				<!-- port -->
                <port>9913</port>
                <!-- 协议类型 -->
				<!-- The type of protocol -->
                <protocol>DODActionRemoting</protocol>
                <!-- -1 则自动获取 -->
				<!-- -1:automatic acquisition -->
                <io-threads>4</io-threads>
                <!--最大连接数 -->
				<!-- The maximum of Connections -->
                <maxConnections>200</maxConnections>
                <!--客户端ip校验正则表达式 -->
				<!-- client ip check regex -->
                <ipCheckRegex></ipCheckRegex>
                <!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
                <msg-threads>16</msg-threads>
                <!--连接最大空闲时间(s) -->
				<!-- Max idle time -->
                <maxChannelIdleTime>0</maxChannelIdleTime>
                <!--连接空闲检查间隔(s) -->
				<!-- The time interval of idle check -->
                <channelIdleCheckInterval>60</channelIdleCheckInterval>
                <!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
                <heartBeatMode>2</heartBeatMode>
                <!--写流量文件间隔(s) -->
				<!-- The time interval of write caps file,the unit is second. -->
                <flowStatWriteInterval>1</flowStatWriteInterval>
                <!--写连接文件间隔(s) -->
				<!-- The time interval of write connection file,the unit is second. -->
                <connectionScanInterval>300</connectionScanInterval>
                <!-- 消息日志级别，FULL；详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
                <writeMsgLogLevel>OFF</writeMsgLogLevel>
                <!--最大总流量 -->
				<!-- The maximum of total caps -->
                <totalCaps>500</totalCaps>
                <!--总流量控制方式0：不控制 1：告警 2：告警并回复过载消息 -->
				<!-- Total caps control mode,0: No control,1: alarm,2: alarm and reply overload message -->
                <totalCapsMode>0</totalCapsMode>
            </params>
            <!--流量相关参数 -->
			<!-- parameters related to caps -->
            <capsControl>
                <totalCaps name="totalFlow" caps="{totalCaps}:500" ctrlMode="{totalCapsMode}:1"></totalCaps>
            </capsControl>
            <!--pipline 构建 -->
			<!--pipline structure -->
            <pipeline factory="com.xxxx.xxx.xxx">
                <!--main pipeline -->
                <main>
                    <handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
                </main>
                <!--child pipeline -->
                <child>
                    <handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
                    <handler name="gateway" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.gateway.ChannelGateway">
                        <job name="connection-scan" runat="connection-scan" interval="{connectionScanInterval}:300" unit="sec" />
                    </handler>
                </child>
                <!--in pipeline -->
                <in>
                    <handler name="readTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
                    <handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
                    <handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ServerSocketOneToOneDecoder" threadPool="{msg-threads}:20" />
                    <handler name="responseImmediately" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.DODActionRemotingReponseHandler" />
                    <handler name="oneway" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.OneWayHandler" />
                    <handler name="nbrTracer" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.NbrTraceHandler" />
                    <handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
                    <handler name="connTimedout" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ActivityValidatingHandler">
                        <job name="connection-timeout" runat="connection-timeout" interval="{channelIdleCheckInterval}:60" unit="sec" />
                        <job name="server-activity" runat="heartbeat-scan" interval="{serverActivityHbInterval}:50" unit="sec" />
                    </handler>
                    <handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
                        <job name="flowStat-write" runat="flowStat-write" interval="{flowStatWriteInterval}:1" unit="sec" />
                    </handler>
                    <handler name="dispatcher" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.PacketDispatcher" />
                </in>
                <!--out pipeline -->
                <out>
                    <handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
                </out>
            </pipeline>
            <!--附属线程 -->
			<!--Additional thread -->
            <jobs-threads>
                <thread name="connection-scan" />
                <thread name="heartbeat-scan" />
                <thread name="connection-timeout" />
                <thread name="flowStat-write" />
            </jobs-threads>
        </adapter>
	</servers>

	<clients>
		<adapter name="TelnetClient" apply="uip" comments="Telnet client test">
			<params>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>5</msg-threads>
			</params>
			<pipeline factory="com.xxxx.xxx.xxx">
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="handler" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.TelnetClientHandler">
						<job name="gather-input" runat="connection-scan" interval="50000" unit="sec" />
					</handler>
					<handler name="linkMonitor" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LinkMonitorHandler">
						<job name="link-monitor" runat="link-monitor" interval="20" unit="millis" />
					</handler>
				</main>
				<in>
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.DelimiterBasedFrameDecoder" />
					<handler name="decoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.string.StringDecoder" threadPool="{msg-threads}:3"/>
					<handler name="handler" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.TelnetClientHandler" />
				</in>
				<out>
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.string.StringEncoder" />
				</out>
			</pipeline>
			<jobs-threads>
				<thread name="connection-scan" />
				<thread name="heartbeat-scan" />
				<thread name="connection-timeout" />
			</jobs-threads>
		</adapter>

		<adapter name="SmsSender" apply="uip" comments="SMPP transmitter client, for uip">
			<params>
				<!-- smsc 服务端地址 -->
				<!-- The IP address of smsc server -->
				<ip>127.0.0.1</ip>
				<!-- smsc 服务端端口 -->
				<!-- The port of smsc server -->
				<port>9001</port>
				<!-- 本机IP地址，一般在多网卡的主机才需要配置-->
				<!-- machine ip address, General in the multi network card host just need to configure -->
				<localIP></localIP>
				<!-- 客户端系统类型 -->
				<!-- The type of client system. -->
				<system_type>uip</system_type>
				<!-- smpp 协议版本, 33 , 34  -->
				<!-- The version of smpp protocol, 33 or 34 -->
				<interface_version>33</interface_version>
				<!-- 缺省短信发送号码 -->
				<!-- The default text messaging number -->
				<source_address>0000</source_address>
				<!-- smsc 登录用户名 -->
				<!-- smsc login user name -->
				<system_id>admin</system_id>
				<!-- smsc 登录密码 -->
				<!-- smsc login user pwd -->
				<password>admin</password>
				<!-- 协议类型 -->
				<!-- The type of protocol -->
				<protocol>SMPP</protocol>
				<!-- 发送的登录指令 -->
				<!-- Send the login command -->
				<loginCommand>BIND_TRANSMITTER</loginCommand>
				<!-- 默认短消息编码方式，0：默认方式,1:ASCII方式,3：iso-8859-1,8：ucs2编码,适用于中文环境,支持汉字 -->
				<!-- The default short message encoding type, 0:default, 1:ASCII, 3:iso-8859-1, 8:ucs2(support Chinese characters) -->
				<data_coding>1</data_coding>
				<!-- 语言对应短信data_coding编码映射关系lang_code=data_coding -->
				<!-- The relationship of language encoding mapping the text message -->
				<lang_code_mapping>2=1|8=8</lang_code_mapping>
				<!-- data_coding与字符集映射关系，没有配置，使用java默认字符集 -->
				<!-- The mapping relationship between data_coding and character set. Using the Java default character set if not configured-->
				<data_coding_mapping>0=SMSC-DEFAULT|1=US-ASCII|2=US-ASCII|3=ISO-8859-1|4=US-ASCII|5=x-JIS0208|6=ISO-8859-5|7=ISO-8859-8|8=UTF-16BE|10=ISO-2022-JP|13=JIS_X0212-1990|14=EUC-KR</data_coding_mapping>
				<!-- 短消息最大字符长度 -->
				<!-- The maximum character length of short message -->
				<max_sm_length>140</max_sm_length>
				<!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
				<heartBeatMode>2</heartBeatMode>
				<!--客户端心跳间隔 -->
				<!-- The client heartbeat interval -->
				<HBInterval>4000</HBInterval>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>5</msg-threads>
				<!-- 请求超时间隔，单位毫秒，缺省15000毫秒 -->
				<!-- Request timeout interval, the unit is millisecond and default is 15000 milliseconds -->
				<connectorTimeout>15000</connectorTimeout>
				<!-- 请求缓冲区大小，用于缓存已经发给服务器端但是还没收到响应的请求的缓存, 缺省值 1500-->
				<!-- The size of request cache,use to cache the request which send to client but haven't received the response,1500 by default. -->
				<requestCache>1500</requestCache>
				<!-- 消息日志级别，FULL；详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
				<writeMsgLogLevel>OFF</writeMsgLogLevel>
				<!--超长短信处理方式，缺省是split。 split：拆分成普通的多条短信；UDHI：拆分发送，但使用User Data Header Indicator flag,可在用户手机上合并显示；payload: 通过TLV message_payload字段在一条消息里发送，SMPP3.4协议开始支持；-->
				<!--Super long message processing method,split by default.split:Split into multiple common messages;UDHI:Split send,use User Data Header Indicator flag,Can be combined to display in the mobile phone;
				payload:Send in a message by TLV message_payload SMPP3.4 agreement to support -->
				<long_message_mode>split</long_message_mode>
			</params>
			<pipeline factory="com.xxxx.xxx.xxx">
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="linkMonitor" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LinkMonitorHandlerSmpp">
						<job name="link-monitor" runat="link-monitor" interval="1000" unit="millis" />
					</handler>
				</main>
				<in>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ClientSocketOneToOneDecoder" threadPool="{msg-threads}:3"/>
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<!--smpp 要在 msgLogger 之后（确保登录应当被打印）， flux 之前（确保deliver消息不会被统计为应答）。-->
					<!-- smpp must after msgLogger,(Ensure that the log should be printed) 
					     and before flux(Ensure that the deliver messages will not be counted as response)-->
					<handler name="smpp" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.smpp.SmppHandler" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.SmppConnectorPacketCache" />
					<handler name="dispatcher" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.ForwardtoBP" />
				</in>
				<out>
					<handler name="smpp" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.smpp.SmppHandler" />
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.SmppConnectorPacketCache" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
				</out>
			</pipeline>
			<jobs-threads>
				<thread name="flowStat-write" />
				<thread name="link-monitor" />
			</jobs-threads>
		</adapter>

		<adapter name="SmsSenderDirect" apply="bp" comments="SMPP transmitter client, for bp or bpJob">
			<params>
				<!-- smsc 服务端地址 -->
				<!-- The IP address of smsc server -->
				<ip>127.0.0.1</ip>
				<!-- smsc 服务端端口 -->
				<!-- The port of smsc server -->
				<port>9001</port>
				<!-- 本机IP地址，一般在多网卡的主机才需要配置-->
				<!-- machine ip address, General in the multi network card host just need to configure -->
				<localIP></localIP>
				<!-- 客户端系统类型 -->
				<!-- The type of client system. -->
				<system_type>uip</system_type>
				<!-- smpp 协议版本, 33 , 34  -->
				<!-- The version of smpp protocol, 33 or 34 -->
				<interface_version>33</interface_version>
				<!-- 缺省短信发送号码 -->
				<!-- The default text messaging number -->
				<source_address>0000</source_address>
				<!-- smsc 登录用户名 -->
				<!-- The login username of smsc server. -->
				<system_id>admin</system_id>
				<!-- smsc 登录密码 -->
				<!-- The login password of smsc server. -->
				<password>admin</password>
				<!-- 协议类型 -->
				<!-- The type of protocol -->
				<protocol>SMPP</protocol>
				<!-- 发送的登录指令 -->
				<!-- Send the login command -->
				<loginCommand>BIND_TRANSMITTER</loginCommand>
				<!-- 默认短消息编码方式，0：默认方式,1:ASCII方式,3：iso-8859-1,8：ucs2编码,适用于中文环境,支持汉字 -->
				<!-- The default short message encoding type, 0:default, 1:ASCII, 3:iso-8859-1, 8:ucs2(support Chinese characters) -->
				<data_coding>1</data_coding>
				<!-- 语言对应短信data_coding编码映射关系lang_code=data_coding -->
				<!-- The relationship of language encoding mapping the text message -->
				<lang_code_mapping>2=1|8=8</lang_code_mapping>
				<!-- data_coding与字符集映射关系，没有配置，使用java默认字符集 -->
				<!-- The mapping relationship between data_coding and character set. Using the Java default character set if not configured-->
				<data_coding_mapping>0=SMSC-DEFAULT|1=US-ASCII|2=US-ASCII|3=ISO-8859-1|4=US-ASCII|5=x-JIS0208|6=ISO-8859-5|7=ISO-8859-8|8=UTF-16BE|10=ISO-2022-JP|13=JIS_X0212-1990|14=EUC-KR</data_coding_mapping>
				<!-- 短消息最大字符长度 -->
				<!-- The maximum character length of short message -->
				<max_sm_length>140</max_sm_length>
				<!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
				<heartBeatMode>2</heartBeatMode>
				<!--客户端心跳间隔 -->
				<!-- The client heartbeat interval -->
				<HBInterval>4000</HBInterval>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>5</msg-threads>
				<!--消息存储队列大小 -->
				<!-- The size of message storage queue-->
				<repositoryQueueSize>100</repositoryQueueSize>
				<!--业务线程池大小,配置为0为系统自动计算;也可根据环境cpu的核数配置,一般是cpu核数*6 -->
				<!-- The thread size of business,0:system automatic calculate; according to the number of nuclei CPU environment configuration, is generally CPU nuclear number *6 -->
				<repositoryThreadSize>16</repositoryThreadSize>
				<!-- 请求超时间隔，单位毫秒，缺省15000毫秒 -->
				<!-- Request timeout interval, the unit is millisecond and default is 15000 milliseconds -->
				<connectorTimeout>15000</connectorTimeout>
				<!-- 请求缓冲区大小，用于缓存已经发给服务器端但是还没收到响应的请求的缓存, 缺省值 1500-->
				<!-- The size of request cache,use to cache the request which send to client but haven't received the response,1500 by default. -->
				<requestCache>1500</requestCache>
				<!-- 消息日志级别，FULL；详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
				<writeMsgLogLevel>OFF</writeMsgLogLevel>
				<!--超长短信处理方式，缺省是split。 split：拆分成普通的多条短信；UDHI：拆分发送，但使用User Data Header Indicator flag,可在用户手机上合并显示；payload: 通过TLV message_payload字段在一条消息里发送，SMPP3.4协议开始支持；-->
				<!--Super long message processing method,split by default.split:Split into multiple common messages;UDHI:Split send,use User Data Header Indicator flag,Can be combined to display in the mobile phone;
				payload:Send in a message by TLV message_payload SMPP3.4 agreement to support -->
				<long_message_mode>split</long_message_mode>
			</params>
			<pipeline factory="com.xxxx.xxx.xxx">
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="linkMonitor" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LinkMonitorHandlerSmpp">
						<job name="link-monitor" runat="link-monitor" interval="1000" unit="millis" />
					</handler>
				</main>
				<in>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ClientSocketOneToOneDecoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<!--smpp 要在 msgLogger 之后（确保登录应当被打印）， flux 之前（确保deliver消息不会被统计为应答）。-->
					<!-- smpp must after msgLogger,(Ensure that the log should be printed) 
					     and before flux(Ensure that the deliver messages will not be counted as response)-->
					<handler name="smpp" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.smpp.SmppHandler" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.SmppConnectorPacketCache" />
					<handler name="commonDirectCall" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.SmppDirectCallHandler" />
					<handler name="repository" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.BPPacketRepository" />
					<handler name="business" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.BusiEngineHandler" />
					<handler name="service" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.ServiceExecutionHandler" />
				</in>
				<out>
					<handler name="smpp" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.smpp.SmppHandler" />
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.SmppConnectorPacketCache" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
				</out>
			</pipeline>
			<jobs-threads>
				<thread name="connection-scan" />
				<thread name="heartbeat-scan" />
				<thread name="connection-timeout" />
				<thread name="link-monitor" />
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>

		<adapter name="SmsReceiver" apply="uip" implement="com.ztesoft.zsmart.uip.adapters.clients.socket.SocketClientAcceptor" comments="SMPP receiver client">
			<params>
				<!-- smsc 服务端地址 -->
				<!-- The address of smsc server -->
				<ip>127.0.0.1</ip>
				<!-- smsc 服务端端口 -->
				<!-- The port of smsc server -->
				<port>9001</port>
				<!-- 本机IP地址，一般在多网卡的主机才需要配置-->
				<!-- machine ip address, General in the multi network card host just need to configure -->
				<localIP></localIP>
				<!-- 客户端系统类型 -->
				<!-- The type of client system. -->
				<system_type>uip</system_type>
				<!-- smpp 协议版本, 33 , 34  -->
				<!-- The version of smpp protocol, 33 or 34 -->
				<interface_version>33</interface_version>
				<!-- 协议类型 -->
				<!-- The type of protocol -->
				<protocol>SMPP</protocol>
				<!-- smsc 登录用户名 -->
				<!-- The login username of smsc server -->
				<system_id>admin</system_id>
				<!-- smsc 登录密码 -->
				<!-- The login password of smsc server -->
				<password>admin</password>
				<!-- 发送的登录指令 -->
				<!-- Send the login command -->
				<loginCommand>BIND_RECEIVER</loginCommand>
				<!-- data_coding与字符集映射关系，没有配置，使用java默认字符集 -->
				<!-- The mapping relationship between data_coding and character set. Using the Java default character set if not configured-->
				<data_coding_mapping>0=SMSC-DEFAULT|1=US-ASCII|2=US-ASCII|3=ISO-8859-1|4=US-ASCII|5=x-JIS0208|6=ISO-8859-5|7=ISO-8859-8|8=UTF-16BE|10=ISO-2022-JP|13=JIS_X0212-1990|14=EUC-KR</data_coding_mapping>
				<!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
				<heartBeatMode>2</heartBeatMode>
				<!--客户端心跳间隔 -->
				<!-- The client heartbeat interval -->
				<HBInterval>4000</HBInterval>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>5</msg-threads>
				<!-- 消息日志级别，FULL；详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
				<writeMsgLogLevel>OFF</writeMsgLogLevel>
			</params>
			<pipeline factory="com.xxxx.xxx.xxx">
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="linkMonitor" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LinkMonitorHandlerSmpp">
						<job name="link-monitor" runat="link-monitor" interval="1000" unit="millis" />
					</handler>
				</main>
				<in>
					<handler name="readTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder"/>
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ClientSocketOneToOneDecoder" threadPool="{msg-threads}:3"/>
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<!--smpp 要在 msgLogger 之后（确保登录应当被打印）， flux 之前（确保deliver消息不会被统计为应答）。-->
					<!-- smpp must after msgLogger,(Ensure that the log should be printed) 
					     and before flux(Ensure that the deliver messages will not be counted as response)-->
					<handler name="smpp" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.smpp.SmppHandler" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="{flowStatWriteInterval}:1" unit="sec" />
					</handler>		
					<handler name="nbrTracer" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.NbrTraceHandler" />			
					<handler name="dispatcher" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.PacketDispatcher" />
				</in>
				<out>
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
					</handler>
				</out>
			</pipeline>
			<jobs-threads>
				<thread name="flowStat-write" />
				<thread name="link-monitor" />
			</jobs-threads>
		</adapter>
		
		<adapter name="SmsSenderAndReceiver" apply="uip" implement="com.ztesoft.zsmart.uip.adapters.clients.socket.SmppSocketClientAcceptor" comments="SMPP transceiver client, for uip">
			<params>
				<!-- smsc 服务端地址 -->
				<!-- The IP address of smsc server -->
				<ip>127.0.0.1</ip>
				<!-- smsc 服务端端口 -->
				<!-- The port of smsc server -->
				<port>9001</port>
				<!-- 本机IP地址，一般在多网卡的主机才需要配置-->
				<!-- machine ip address, General in the multi network card host just need to configure -->
				<localIP></localIP>
				<!-- 客户端系统类型 -->
				<!-- The type of client system. -->
				<system_type>uip</system_type>
				<!-- smpp 协议版本, 33 , 34  -->
				<!-- The version of smpp protocol, 33 or 34 -->
				<interface_version>33</interface_version>
				<!-- 缺省短信发送号码 -->
				<!-- The default text messaging number -->
				<source_address>0000</source_address>
				<!-- smsc 登录用户名 -->
				<!-- The login username of smsc server. -->
				<system_id>admin</system_id>
				<!-- smsc 登录密码 -->
				<!-- The login password of smsc server. -->
				<password>admin</password>
				<!-- 协议类型 -->
				<!-- The type of protocol -->
				<protocol>SMPP</protocol>
				<!-- 发送的登录指令 -->
				<!-- Send the login command -->
				<loginCommand>BIND_TRANSCEIVER</loginCommand>
				<!-- 默认短消息编码方式，0：默认方式,1:ASCII方式,3：iso-8859-1,8：ucs2编码,适用于中文环境,支持汉字 -->
				<!-- The default short message encoding type, 0:default, 1:ASCII, 3:iso-8859-1, 8:ucs2(support Chinese characters) -->
				<data_coding>1</data_coding>
				<!-- 语言对应短信data_coding编码映射关系lang_code=data_coding -->
				<!-- The relationship of language encoding mapping the text message -->
				<lang_code_mapping>2=1|8=8</lang_code_mapping>
				<!-- data_coding与字符集映射关系，没有配置，使用java默认字符集 -->
				<!-- The mapping relationship between data_coding and character set. Using the Java default character set if not configured-->
				<data_coding_mapping>0=SMSC-DEFAULT|1=US-ASCII|2=US-ASCII|3=ISO-8859-1|4=US-ASCII|5=x-JIS0208|6=ISO-8859-5|7=ISO-8859-8|8=UTF-16BE|10=ISO-2022-JP|13=JIS_X0212-1990|14=EUC-KR</data_coding_mapping>
				<!-- 短消息最大字符长度 -->
				<!-- The maximum character length of short message -->
				<max_sm_length>140</max_sm_length>
				<!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
				<heartBeatMode>2</heartBeatMode>
				<!--客户端心跳间隔 -->
				<!-- The client heartbeat interval -->
				<HBInterval>4000</HBInterval>
				<!--解码器线程池大小，需要配置在 16 以上，因为可能需要回调 submitAsynService  -->
				<!-- The size of decoder thread pool,must more than 16,because may be callback submitAsynService -->
				<msg-threads>24</msg-threads>
				<!-- 请求超时间隔，单位毫秒，缺省15000毫秒 -->
				<!-- Request timeout interval, the unit is millisecond and default is 15000 milliseconds -->
				<connectorTimeout>15000</connectorTimeout>
				<!-- 请求缓冲区大小，用于缓存已经发给服务器端但是还没收到响应的请求的缓存, 缺省值 1500-->
				<!-- The size of request cache,use to cache the request which send to client but haven't received the response,1500 by default. -->
				<requestCache>1500</requestCache>
				<!-- 消息日志级别，FULL；详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
				<writeMsgLogLevel>OFF</writeMsgLogLevel>
				<!-- 短信超出发送时间之后处理服务，缺省空，可以填 AdviceDelayService -->
				<!-- The handle service for the timeout short message, null by default, can be AdviceDelayService -->
				<adviceDelayService></adviceDelayService>
				<!--超长短信处理方式，缺省是split。 split：拆分成普通的多条短信；UDHI：拆分发送，但使用User Data Header Indicator flag,可在用户手机上合并显示；payload: 通过TLV message_payload字段在一条消息里发送，SMPP3.4协议开始支持； -->
				<!--Super long message processing method,split by default.split:Split into multiple common messages;UDHI:Split send,use User Data Header Indicator flag,Can be combined to display in the mobile phone;payload:Send in a message by TLV message_payload 
				SMPP3.4 agreement to support -->
				<long_message_mode>split</long_message_mode>
			</params>
			<pipeline factory="com.xxxx.xxx.xxx">
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="linkMonitor" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LinkMonitorHandlerSmpp">
						<job name="link-monitor" runat="link-monitor" interval="1000" unit="millis" />
					</handler>
				</main>
				<in>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ClientSocketOneToOneDecoder" threadPool="{msg-threads}:3"/>
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<!--smpp 要在 msgLogger 之后（确保登录应当被打印）， flux 之前（确保deliver消息不会被统计为应答）。-->
					<!-- smpp must after msgLogger,(Ensure that the log should be printed) 
					     and before flux(Ensure that the deliver messages will not be counted as response)-->
					<handler name="smpp" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.smpp.SmppHandler" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.SmppConnectorPacketCache" />
					<handler name="dispatcher" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.ForwardtoBP4Smpp" />
					<handler name="dispatcherDeliverSm" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.SmppPacketDispatcher" />
				</in>
				<out>
					<handler name="smpp" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.smpp.SmppHandler" />
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.SmppConnectorPacketCache" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.SmppFluxGateway"/>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
				</out>
			</pipeline>
			<jobs-threads>
				<thread name="flowStat-write" />
				<thread name="link-monitor" />
			</jobs-threads>
		</adapter>

		<adapter name="SmsGatewayAgent" apply="uip" implement="com.ztesoft.zsmart.uip.adapters.clients.socket.SocketClientAcceptor" comments="SMPP Client as Gateway Agent, for uip">
			<params>
				<!-- smsc 服务端地址 -->
				<!-- The IP address of smsc server -->
				<ip>127.0.0.1</ip>
				<!-- smsc 服务端端口 -->
				<!-- The port of smsc server -->
				<port>9001</port>
				<!-- 本机IP地址，一般在多网卡的主机才需要配置-->
				<!-- machine ip address, General in the multi network card host just need to configure -->
				<localIP></localIP>
				<!-- 客户端系统类型 -->
				<!-- The type of client system. -->
				<system_type>uip</system_type>
				<!-- smpp 协议版本, 33 , 34  -->
				<!-- The version of smpp protocol, 33 or 34 -->
				<interface_version>33</interface_version>
				<!-- 缺省短信发送号码 -->
				<!-- The default text messaging number -->
				<source_address>0000</source_address>
				<!-- smsc 登录用户名 -->
				<!-- The login username of smsc server -->
				<system_id>admin</system_id>
				<!-- smsc 登录密码 -->
				<!-- The login password of smsc server -->
				<password>admin</password>
				<!-- 协议类型 -->
				<!-- The type of protocol -->
				<protocol>SMPP</protocol>
				<!-- 发送的登录指令 -->
				<!-- Send the login command -->
				<loginCommand>BIND_TRANSCEIVER</loginCommand>
				<!-- 默认短消息编码方式，0：默认方式,1:ASCII方式,3：iso-8859-1,8：ucs2编码,适用于中文环境,支持汉字 -->
				<!-- The default short message encoding type, 0:default, 1:ASCII, 3:iso-8859-1, 8:ucs2(support Chinese characters) -->
				<data_coding>1</data_coding>
				<!-- 语言对应短信data_coding编码映射关系lang_code=data_coding -->
				<!-- The relationship of language encoding mapping the text message -->
				<lang_code_mapping>2=1|8=8</lang_code_mapping>
				<!-- data_coding与字符集映射关系，没有配置，使用java默认字符集 -->
				<!-- The mapping relationship between data_coding and character set. Using the Java default character set if not configured-->
				<data_coding_mapping>0=SMSC-DEFAULT|1=US-ASCII|2=US-ASCII|3=ISO-8859-1|4=US-ASCII|5=x-JIS0208|6=ISO-8859-5|7=ISO-8859-8|8=UTF-16BE|10=ISO-2022-JP|13=JIS_X0212-1990|14=EUC-KR</data_coding_mapping>
				<!-- 短消息最大字符长度 -->
				<!-- The maximum character length of short message -->
				<max_sm_length>140</max_sm_length>
				<!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
				<heartBeatMode>2</heartBeatMode>
				<!--客户端心跳间隔 -->
				<!-- The client heartbeat interval -->
				<HBInterval>4000</HBInterval>
				<!--解码器线程池大小，需要配置在 16 以上，因为可能需要处理业务逻辑  -->
				<!-- The size of decoder thread pool,must more than 16,because may be need deal business -->
				<msg-threads>24</msg-threads>
				<!-- 请求超时间隔，单位毫秒，缺省15000毫秒 -->
				<!-- Request timeout interval, the unit is millisecond and default is 15000 milliseconds -->
				<connectorTimeout>30000</connectorTimeout>
				<!-- 请求缓冲区大小，用于缓存已经发给服务器端但是还没收到响应的请求的缓存, 缺省值 1500-->
				<!-- The size of request cache,use to cache the request which send to client but haven't received the response,1500 by default. -->
				<requestCache>1500</requestCache>
				<!-- 消息日志级别，FULL；详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
				<writeMsgLogLevel>OFF</writeMsgLogLevel>
			</params>
			<pipeline factory="com.xxxx.xxx.xxx">
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="linkMonitor" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LinkMonitorHandlerSmpp">
						<job name="link-monitor" runat="link-monitor" interval="1000" unit="millis" />
					</handler>
				</main>
				<in>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ClientSocketOneToOneDecoder" threadPool="{msg-threads}:3"/>
					<!--smpp 要在 msgLogger 之后（确保登录应当被打印）， flux 之前（确保deliver消息不会被统计为应答）。-->
					<!-- smpp must after msgLogger,(Ensure that the log should be printed) 
					     and before flux(Ensure that the deliver messages will not be counted as response)-->
					<handler name="smpp" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.smpp.SmppHandler" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.SmppConnectorPacketCache" />
					<handler name="gateWayHandler" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.smpp.SmppGateWayHandler" />
				</in>
				<out>
					<handler name="gateWayHandler" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.smpp.SmppGateWayHandler" />
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.SmppConnectorPacketCache" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
				</out>
			</pipeline>
			<jobs-threads>
				<thread name="flowStat-write" />
				<thread name="link-monitor" />
			</jobs-threads>
		</adapter>

		<adapter name="MMLBusiClient" apply="remoting" comments="MML direct call client, for bp/jobservices/web">
			<params>
				<protocol>MML</protocol>
				<!-- mml 服务端地址 -->
				<!-- The address of mml server -->
				<ip>127.0.0.1</ip>
				<!-- mml 服务端端口 -->
				<!-- The port of mml server -->
				<port>9901</port>
				<!-- 本机IP地址，一般在多网卡的主机才需要配置-->
				<!-- machine ip address, General in the multi network card host just need to configure -->
				<localIP></localIP>
				<!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
				<heartBeatMode>1</heartBeatMode>
				<!--客户端心跳间隔 -->
				<!-- The client heartbeat interval -->
				<HBInterval>4000</HBInterval>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>5</msg-threads>
				<!-- 请求超时间隔，单位毫秒，缺省15000毫秒 -->
				<!-- Request timeout interval, the unit is millisecond and default is 15000 milliseconds -->
				<connectorTimeout>15000</connectorTimeout>
				<!-- 请求缓冲区大小，用于缓存已经发给服务器端但是还没收到响应的请求的缓存, 缺省值 1500-->
				<!-- The size of request cache,use to cache the request which send to client but haven't received the response,1500 by default. -->
				<requestCache>1500</requestCache>
				<!--mml登录用户名-->
			    <!-- The login username of mml -->
				<user>admin</user>
				<!--mml密码-->
				 <!-- The login pwd of mml -->
				<pswd>1</pswd>
				<!--切包失败超过这个次数，就关闭连接，默认是2，有包头的协议可以调大-->
				<!-- the maximum Split Error Times,the connection will be closed when the num more than maximum,2 by default,the num can be adjusted to a big if protocol has head-->
				<maxSplitErrorTimes>10</maxSplitErrorTimes>
				<!--mml协议开始标记切包的时候有用到-->
				<!-- mml protocol begin flag -->
				<mmlBeginFlagStr>`SC`</mmlBeginFlagStr>
			</params>
			<pipeline factory="com.xxxx.xxx.xxx">
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="linkMonitor" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LinkMonitorHandlerMML">
						<job name="link-monitor" runat="link-monitor" interval="1000" unit="millis" />
					</handler>
				</main>
				<in>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ClientSocketOneToOneDecoder" threadPool="{msg-threads}:3" />
					<handler name="V62Adapter" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.mml.V62Adapter" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="mmlClient" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.MMLClientHandler" />
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.MMLConnectorPacketCache" />
					<handler name="business" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.BusiEngineHandler" />
					<handler name="commonDirectCall" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.CommonDirectCallHandler" />
				</in>
				<out>
					<handler name="business" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.BusiEngineHandler" />
					<handler name="mmlClient" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.MMLClientHandler" />
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.MMLConnectorPacketCache" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
				</out>
			</pipeline>
			<jobs-threads>
				<thread name="heartbeat-scan" />
				<thread name="connection-timeout" />
				<thread name="link-monitor" />
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>

		<adapter name="WinTcpCollectClient" apply="remoting" comments="WINTCP direct call client, for collect">
			<params>
				<protocol>WINTCP</protocol>
				<port>6008</port>
				<!-- 本机IP地址，一般在多网卡的主机才需要配置-->
				<!-- machine ip address, General in the multi network card host just need to configure -->
				<localIP></localIP>
				<senderPno>143</senderPno>
				<senderUnit>143</senderUnit>
				<senderModule>143</senderModule>
				<senderPostOffice>174</senderPostOffice>
				<reciverPno>100:65005,65006,65007,65009</reciverPno>
				<receiverUnit>0</receiverUnit>
				<receiverModule>138</receiverModule>
				<receiverPostOffice>176</receiverPostOffice>
				<!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
				<heartBeatMode>1</heartBeatMode>
				<!--客户端心跳间隔 -->
				<!-- The client heartbeat interval -->
				<HBInterval>4000</HBInterval>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>5</msg-threads>
				<!-- 请求超时间隔，单位毫秒，缺省15000毫秒 -->
				<!-- Request timeout interval, the unit is millisecond and default is 15000 milliseconds -->
				<connectorTimeout>15000</connectorTimeout>
				<!-- 请求缓冲区大小，用于缓存已经发给服务器端但是还没收到响应的请求的缓存, 缺省值 1500-->
				<!-- The size of request cache,use to cache the request which send to client but haven't received the response,1500 by default. -->
				<requestCache>1500</requestCache>
			</params>
			<pipeline factory="com.xxxx.xxx.xxx">
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="linkMonitor" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LinkMonitorHandlerWinTcpCollect">
						<job name="link-monitor" runat="link-monitor" interval="1000" unit="millis" />
					</handler>
				</main>
				<in>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ClientSocketOneToOneDecoder" threadPool="{msg-threads}:3"/>
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.WintcpConnectorPacketCache" />
					<handler name="business" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.BusiEngineHandler" />
					<handler name="commonDirectCall" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.CommonDirectCallHandler" />
					<handler name="service" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.ServerPushServExeHandler" />
				</in>
				<out>
					<handler name="business" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.BusiEngineHandler" />
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.WintcpConnectorPacketCache" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
				</out>
			</pipeline>
			<jobs-threads>				
				<thread name="heartbeat-scan" />
				<thread name="connection-timeout" />
				<thread name="link-monitor" />
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>

		<adapter name="WinTcpBusiClient" apply="remoting" comments="WINTCP direct call client, for bp/jobservices/web">
			<params>
				<!-- ip地址 -->
				<!-- IP address -->
				<ip>10.45.7.83</ip>
				<!-- 端口-->
				<!-- ip port -->
				<port>5002</port>
				<!-- 本机IP地址，一般在多网卡的主机才需要配置-->
				<!-- machine ip address, General in the multi network card host just need to configure -->
				<localIP></localIP>
				<!-- 协议类型 -->
				<!-- The type of protocol -->
				<protocol>WINTCP</protocol>
				<!-- 发送者进程号 -->
				<!-- The process No. of sender -->
				<senderPno>99</senderPno>
				<!-- 发送者uinit -->
				<!-- The unit of sender -->
				<senderUnit>0</senderUnit>
				<!-- 发送者节点号，要求大于128，小于255 ，senderModule 跟  senderPostOffice 一般配置成一样-->
				<!-- The module of sender,must between 128 and 255,Generally,senderModule and senderPostOffice is configured for the same-->
				<senderModule>166</senderModule>
				<!-- 发送者局号，要求大于128，小于255 ，senderModule 跟  senderPostOffice 一般配置成一样-->
				<!-- The post of sender,must between 128 and 255,Generally,senderModule and senderPostOffice is configured for the same-->
				<senderPostOffice>166</senderPostOffice>
				<!-- 接收者进程号映射列表。格式：进程1:事件1,事件2;进程2:事件2 , 进程之间用分号隔开，事件之间用逗号隔开。注意是半角字符 -->
				<!-- The receiver process mapping list No.Format: the process of 1: event 1, event 2; process 2: event 2.
				     Process between separated by semicolons, events are separated by commas -->
				<reciverPno>1:1|123:58001|140:58011|106:58003|108:58007,58015,58017,58019,58023|141:58012|142:58013|143:58014|160:58031</reciverPno>
				<!-- 接收者单元号 -->
				<!-- The unit of receiver -->
				<receiverUnit>0</receiverUnit>
				<!-- 接收者节点号，需要参考 zxos 配置 -->
				<!-- The module of receiver,need reference the configuration of zxos -->
				<receiverModule>136</receiverModule>
				<!-- 接收者局号 ，需要参考 zxos 配置-->
				<!-- The post of receiver,need reference the configuration of zxos -->
				<receiverPostOffice>176</receiverPostOffice>
				<!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
				<heartBeatMode>1</heartBeatMode>
				<!--客户端心跳间隔 -->
				<!-- The client heartbeat interval -->
				<HBInterval>40000</HBInterval>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>5</msg-threads>
				<!-- 请求超时间隔，单位毫秒，缺省15000毫秒 -->
				<!-- Request timeout interval, the unit is millisecond and default is 15000 milliseconds -->
				<connectorTimeout>5000</connectorTimeout>
				<!-- 请求缓冲区大小，用于缓存已经发给服务器端但是还没收到响应的请求的缓存, 缺省值 1500-->
				<!-- The size of request cache,use to cache the request which send to client but haven't received the response,1500 by default. -->
				<requestCache>1500</requestCache>
			</params>
			<pipeline factory="com.xxxx.xxx.xxx">
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="linkMonitor" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LinkMonitorHandlerWinTcp">
						<job name="link-monitor" runat="link-monitor" interval="1000" unit="millis" />
					</handler>
				</main>
				<in>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ClientSocketOneToOneDecoder" threadPool="{msg-threads}:3" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.ConnectorPacketCache" />
					<handler name="business" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.BusiEngineHandler" />
					<handler name="commonDirectCall" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.CommonDirectCallHandler" />
				</in>
				<out>
					<handler name="business" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.BusiEngineHandler" />
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.ConnectorPacketCache" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
				</out>
			</pipeline>
			<jobs-threads>
				<thread name="heartbeat-scan" />
				<thread name="connection-timeout" />
				<thread name="link-monitor" />
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>
		
		<adapter name="WinTcpClient" apply="uip" comments="WINTCP client for uip">
			<params>
				<!-- ip地址 -->
				<!-- IP address -->
				<ip>10.45.7.83</ip>
				<!-- 端口-->
				<!-- ip port -->
				<port>5002</port>
				<!-- 本机IP地址，一般在多网卡的主机才需要配置-->
				<!-- machine ip address, General in the multi network card host just need to configure -->
				<localIP></localIP>
				<!-- 协议类型 -->
				<!-- The type of protocol -->
				<protocol>WINTCP</protocol>
				<!-- 发送者局号 -->
				<!-- The post of sender-->
				<senderPno>99</senderPno>
				<!-- 发送者uinit -->
				<!-- The unit of sender-->
				<senderUnit>0</senderUnit>
				<!-- 发送者节点号，要求大于128，小于255 ，senderModule 跟  senderPostOffice 一般配置成一样-->
				<!-- The module of sender,must between 128 and 255,Generally,senderModule and senderPostOffice is configured for the same-->
				<senderModule>156</senderModule>
				<!-- 发送者局号，要求大于128，小于255 ，senderModule 跟  senderPostOffice 一般配置成一样-->
				<!-- The post of sender,must between 128 and 255,Generally,senderModule and senderPostOffice is configured for the same-->
				<senderPostOffice>156</senderPostOffice>
				<!-- 接收者进程号映射列表。格式：进程1:事件1,事件2;进程2:事件2 , 进程之间用分号隔开，事件之间用逗号隔开。注意是半角字符 -->
				<!-- The receiver process mapping list No.Format: the process of 1: event 1, event 2; process 2: event 2.
				     Process between separated by semicolons, events are separated by commas -->
				<reciverPno>1:1|123:58001|140:58011|106:58003|108:58007,58015,58017,58019,58023|141:58012|142:58013|143:58014|160:58031</reciverPno>
				<!-- 接收者单元号 -->
				<!-- The unit of receiver -->
				<receiverUnit>0</receiverUnit>
				<!-- 接收者节点号，需要参考 zxos 配置 -->
				<!-- The module of receiver,need reference the configuration of zxos -->
				<receiverModule>136</receiverModule>
				<!-- 接收者局号 ，需要参考 zxos 配置-->
				<!-- The post of receiver,need reference the configuration of zxos -->
				<receiverPostOffice>176</receiverPostOffice>
				<!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
				<heartBeatMode>1</heartBeatMode>
				<!--客户端心跳间隔 -->
				<!-- The client heartbeat interval -->
				<HBInterval>4000</HBInterval>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>5</msg-threads>
				<!-- 请求超时间隔，单位毫秒，缺省15000毫秒 -->
				<!-- Request timeout interval, the unit is millisecond and default is 15000 milliseconds -->
				<connectorTimeout>5000</connectorTimeout>
				<!-- 请求缓冲区大小，用于缓存已经发给服务器端但是还没收到响应的请求的缓存, 缺省值 1500-->
				<!-- The size of request cache,use to cache the request which send to client but haven't received the response,1500 by default. -->
				<requestCache>1500</requestCache>
			</params>
			<pipeline factory="com.xxxx.xxx.xxx">
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="linkMonitor" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LinkMonitorHandlerWinTcp">
						<job name="link-monitor" runat="link-monitor" interval="1000" unit="millis" />
					</handler>
				</main>
				<in>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ClientSocketOneToOneDecoder" threadPool="{msg-threads}:3"/>
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.ConnectorPacketCache" />
					<handler name="dispatcher" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.ForwardtoBP" />
				</in>
				<out>
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.ConnectorPacketCache" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
				</out>
			</pipeline>
			<jobs-threads>
				<thread name="heartbeat-scan" />
				<thread name="connection-timeout" />
				<thread name="link-monitor" />
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>

		<adapter name="HTTPClient" apply="remoting" implement="com.ztesoft.zsmart.uip.adapters.clients.http.BasicHttpClientAdapter" comments="Using Apache HTTP Client">
			<params>
				<!-- ip地址 -->
				<!-- IP address -->
				<server>http://127.0.0.1:8080/</server>
				<!-- 本机IP地址，一般在多网卡的主机才需要配置-->
				<!-- machine ip address, General in the multi network card host just need to configure -->
				<localIP></localIP>
				<!--协议名称 -->
				<!-- The name of protocol -->
				<protocol>HttpCommon</protocol>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>5</msg-threads>
				<!-- 连接超时，缺省15000毫秒 -->
				<!-- connection Timeout,15000 by default. -->
				<connectionTimeout>20000</connectionTimeout>
				<!-- 请求超时，缺省60000毫秒 -->
				<!-- request Timeout,60000 by default. -->
				<requestTimeout>60000</requestTimeout>
				<!-- 是否启用 keep-alive，缺省启用 -->
				<!-- Whether to enable keep-alive,true by default. -->
				<keepalive>true</keepalive>
				<!-- 最大连接个数，缺省 32 -->
				<!-- The maximum of client connection,32 by default. -->
				<maxClient>60</maxClient>
				<!-- 请求缓冲区大小，用于缓存已经发给服务器端但是还没收到响应的请求的缓存, 缺省值 1500-->
				<!-- The size of request cache,use to cache the request which send to client but haven't received the response,1500 by default. -->
				<requestCache>1500</requestCache>
			</params>
			<pipeline factory="com.xxxx.xxx.xxx">
				<in>
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ClientSocketOneToOneDecoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="business" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.BusiEngineHandler" />
				</in>
				<out>
					<handler name="business" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.BusiEngineHandler" />
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
				</out>
			</pipeline>
			<jobs-threads>
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>
		
		<adapter name="HttpRemotingClient" apply="remoting" implement="com.ztesoft.zsmart.uip.adapters.clients.http.BasicHttpClientAdapter" comments="Using Apache HTTP Client to call V7 service">
            <params>
                <!-- URL地址 -->
				<!-- The address of url -->
                <server>http://localhost:8889/mock-V7BusifacadeServlet/callRemotingService.do</server>
                <!--协议名称 -->
				<!-- The name of protocol -->
                <protocol>HttpRemoting</protocol>
                <!-- 是否启用 keep-alive，缺省不启用 -->
				<!-- Whether to enable keep-alive,false by default. -->
                <keepalive>false</keepalive>
            </params>
            <pipeline factory="com.xxxx.xxx.xxx">
                <in>
                    <handler name="remotingDecoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.message.http.HttpRemotingDecoder" />
                </in>
                <out>
                </out>
            </pipeline>
            <jobs-threads>
            </jobs-threads>
        </adapter>

		<adapter name="WebServiceClient" apply="remoting" implement="com.ztesoft.zsmart.uip.adapters.clients.ws.BasicWSClientAdapter" comments="Using AXIS2 Client">
			<params>
				<!-- ip地址 -->
				<!-- IP address -->
				<server>http://127.0.0.1:8080/</server>
				<!--协议名称 -->
				<!-- The name of protocol -->
				<protocol>ACCOUNT</protocol>
				<!--soap协议版本，缺省是 1 , 0: http, 1: soap1.0 , 2:soap1.2 ,   -->
				<!-- The version of soap protocol,1 by default, 0: http, 1: soap1.0 , 2:soap1.2-->
				<soapVersion>1</soapVersion>
				<!--最大http 客户端连接个数，缺省 40-->
				<!-- The maximum of client connection,40 by default. -->
				<maxConnection>80</maxConnection>
				<!-- 连接超时，缺省20000毫秒 -->
				<!-- connection Timeout,20000 by default. -->
				<connectionTimeout>25000</connectionTimeout>
				<!-- 请求超时，缺省60000毫秒 -->
				<!-- request Timeout,60000 by default. -->
				<requestTimeout>60000</requestTimeout>
				<!-- 是否启用 keep-alive，缺省启用 -->
				<!-- Whether to enable keep-alive,true by default. -->
				<keepalive>true</keepalive>
				<!-- 最大连接个数，缺省 32 -->
				<!-- The maximum of client connection,32 by default. -->
				<maxClient>60</maxClient>
				<!-- 请求缓冲区大小，用于缓存已经发给服务器端但是还没收到响应的请求的缓存, 缺省值 1500-->
				<!-- The size of request cache,use to cache the request which send to client but haven't received the response,1500 by default. -->
				<requestCache>1500</requestCache>
			</params>
			<pipeline factory="com.xxxx.xxx.xxx">
				<in>
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ClientSocketOneToOneDecoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="business" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.BusiEngineHandler" />
				</in>
				<out>
					<handler name="business" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.BusiEngineHandler" />
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
				</out>
			</pipeline>
			<jobs-threads>
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>

		<adapter name="VCClient" apply="uip" comments="VC Client">
			<params>
				<protocol>VC_Client</protocol>
				<!-- 本机IP地址，一般在多网卡的主机才需要配置-->
				<!-- machine ip address, General in the multi network card host just need to configure -->
				<localIP></localIP>
				<!-- 接口版本 -->
				<!-- The version of interface -->
				<InterfaceVersion>1</InterfaceVersion>
				<!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
				<heartBeatMode>2</heartBeatMode>
				<!--客户端心跳间隔 -->
				<!-- The client heartbeat interval -->
				<HBInterval>4000</HBInterval>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>5</msg-threads>
				<!-- 请求超时间隔，单位毫秒，缺省15000毫秒 -->
				<!-- Request timeout interval, the unit is millisecond and default is 15000 milliseconds -->
				<connectorTimeout>15000</connectorTimeout>
				<!-- 请求缓冲区大小，用于缓存已经发给服务器端但是还没收到响应的请求的缓存, 缺省值 1500-->
				<!-- The size of request cache,use to cache the request which send to client but haven't received the response,1500 by default. -->
				<requestCache>1500</requestCache>
			</params>
			<pipeline factory="com.xxxx.xxx.xxx">
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="linkMonitor" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LinkMonitorHandlerVCClient">
						<job name="link-monitor" runat="link-monitor" interval="1000" unit="millis" />
					</handler>
				</main>
				<in>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ClientSocketOneToOneDecoder" threadPool="{msg-threads}:3"/>
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="VCClient" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.VCClientHandler" />
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.ConnectorPacketCache" />
					<handler name="dispatcher" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.ForwardtoBP" />
				</in>
				<out>
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.ConnectorPacketCache" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
				</out>
			</pipeline>
			<jobs-threads>
				<thread name="flowStat-write" />
				<thread name="link-monitor" />
			</jobs-threads>
		</adapter>

		<adapter name="HTTPSocketClient" apply="uip" comments="HTTP Client">
			<params>
				<!-- ip地址 -->
				<!-- IP address -->
				<ip>127.0.0.1</ip>
				<!-- 端口 -->
				<!-- ip port -->
				<port>8080</port>
				<!-- 本机IP地址，一般在多网卡的主机才需要配置-->
				<!-- machine ip address, General in the multi network card host just need to configure -->
				<localIP></localIP>
				<!--协议名称 -->
				<!-- The name of protocol -->
				<protocol>HttpBinary</protocol>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>5</msg-threads>
				<!-- 请求超时间隔，单位毫秒，缺省15000毫秒 -->
				<!-- Request timeout interval, the unit is millisecond and default is 15000 milliseconds -->
				<connectorTimeout>60000</connectorTimeout>
				<!-- 请求缓冲区大小，用于缓存已经发给服务器端但是还没收到响应的请求的缓存, 缺省值 1500-->
				<!-- The size of request cache,use to cache the request which send to client but haven't received the response,1500 by default. -->
				<requestCache>1500</requestCache>
			</params>
			<pipeline factory="com.xxxx.xxx.xxx">
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="linkMonitor" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LinkMonitorHandlerVCClient">
						<job name="link-monitor" runat="link-monitor" interval="1000" unit="millis" />
					</handler>
				</main>
				<in>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="httpDecoder" inst-type="single" class="org.jboss.netty.handler.codec.http.HttpClientCodec" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ClientSocketOneToOneDecoder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.ConnectorPacketCache" />
					<handler name="dispatcher" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.ForwardtoBP" />
				</in>
				<out>
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.ConnectorPacketCache" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="httpEncoder" inst-type="single" class="org.jboss.netty.handler.codec.http.HttpClientCodec" />
				</out>
			</pipeline>
			<jobs-threads>
				<thread name="flowStat-write" />
				<thread name="link-monitor" />
			</jobs-threads>
		</adapter>

		<adapter name="RemotingBusiConnector" apply="remoting" comments="RemotingBusiConnector , jobservice/web/bp -> jobservice/web/bp">
			<params>
				<!-- ip地址 -->
				<!-- IP address -->
				<ip>127.0.0.1</ip>
				<!-- 端口 -->
				<!-- ip port -->
				<port>9660</port>
				<!-- 本机IP地址，一般在多网卡的主机才需要配置-->
				<!-- machine ip address, General in the multi network card host just need to configure -->
				<localIP></localIP>
				<io-threads>4</io-threads>
				<!-- 协议类型 -->
				<!-- The type of protocol -->
				<protocol>Remoting</protocol>
				<!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
				<heartBeatMode>2</heartBeatMode>
				<!--客户端心跳间隔 -->
				<!-- The client heartbeat interval -->
				<HBInterval>4000</HBInterval>
				<!--切包失败超过这个次数，就关闭连接，默认是2，有包头的协议可以调大 -->
				<!-- the maximum Split Error Times,the connection will be closed when the num more than maximum,2 by default,the num can be adjusted to a big if protocol has head-->
				<maxSplitErrorTimes>10</maxSplitErrorTimes>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>5</msg-threads>
				<!-- 请求超时间隔，单位毫秒，缺省15000毫秒 -->
				<!-- Request timeout interval, the unit is millisecond and default is 15000 milliseconds -->
				<connectorTimeout>60000</connectorTimeout>
				<!-- 请求缓冲区大小，用于缓存已经发给服务器端但是还没收到响应的请求的缓存, 缺省值 1500-->
				<!-- The size of request cache,use to cache the request which send to client but haven't received the response,1500 by default. -->
				<requestCache>1500</requestCache>
				<!-- 消息日志级别，FULL；详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
				<writeMsgLogLevel>OFF</writeMsgLogLevel>
			</params>
			<pipeline factory="com.xxxx.xxx.xxx">
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="linkMonitor" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LinkMonitorHandler">
						<job name="link-monitor" runat="link-monitor" interval="1" unit="sec" />
					</handler>
				</main>
				<in>
					<handler name="readTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ClientSocketOneToOneDecoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.ConnectorPacketCache" />
					<handler name="remotingDirectCall" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.RemotingDirectCallHamdler" />
				</in>
				<out>
					<!--对于 Remoting 协议，必须先 cache 再 encoder -->
					<!-- For the Remoting protocol,cache must before encoder -->
					<handler name="remotingDirectCall" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.RemotingDirectCallHamdler" />
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.ConnectorPacketCache" />
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
				</out>
			</pipeline>
			<jobs-threads>
				<thread name="link-monitor" />
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>

		<adapter name="SmppBusiConnector" apply="remoting" comments="SmppBusiConnector , jobservice/web/bp -> smsc">
			<params>
				<!-- smsc 服务端地址 -->
				<!-- The IP address of smsc server -->
				<ip>127.0.0.1</ip>
				<!-- smsc 服务端端口 -->
				<!-- The port of smsc server -->
				<port>9001</port>
				<!-- 本机IP地址，一般在多网卡的主机才需要配置-->
				<!-- machine ip address, General in the multi network card host just need to configure -->
				<localIP></localIP>
				<!-- 客户端系统类型 -->
				<!-- The type of client system. -->
				<system_type>uip</system_type>
				<!-- smpp 协议版本, 33 , 34  -->
				<!-- The version of smpp protocol, 33 or 34 -->
				<interface_version>33</interface_version>
				<!-- 缺省短信发送号码 -->
				<!-- The default text messaging number -->
				<source_address>0000</source_address>
				<!-- smsc 登录用户名 -->
				<!-- The login username of smsc server -->
				<system_id>admin</system_id>
				<!-- smsc 登录密码 -->
				<!-- The login password of smsc server -->
				<password>admin</password>
				<!-- 协议类型 -->
				<!-- The type of protocol -->
				<protocol>SMPP</protocol>
				<!-- 发送的登录指令 -->
				<!-- Send the login command -->
				<loginCommand>BIND_TRANSCEIVER</loginCommand>
				<!-- 默认短消息编码方式，0：默认方式,1:ASCII方式,3：iso-8859-1,8：ucs2编码,适用于中文环境,支持汉字 -->
				<!-- The default short message encoding type, 0:default, 1:ASCII, 3:iso-8859-1, 8:ucs2(support Chinese characters) -->
				<data_coding>1</data_coding>
				<!-- 语言对应短信data_coding编码映射关系lang_code=data_coding -->
				<!-- The relationship of language encoding mapping the text message -->
				<lang_code_mapping>2=1|8=8</lang_code_mapping>
				<!-- data_coding与字符集映射关系，没有配置，使用java默认字符集 -->
				<!-- The mapping relationship between data_coding and character set. Using the Java default character set if not configured-->
				<data_coding_mapping>0=SMSC-DEFAULT|1=US-ASCII|2=US-ASCII|3=ISO-8859-1|4=US-ASCII|5=x-JIS0208|6=ISO-8859-5|7=ISO-8859-8|8=UTF-16BE|10=ISO-2022-JP|13=JIS_X0212-1990|14=EUC-KR</data_coding_mapping>
				<!-- 短消息最大字符长度 -->
				<!-- The maximum character length of short message -->
				<max_sm_length>140</max_sm_length>
				<!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
				<heartBeatMode>2</heartBeatMode>
				<!--客户端心跳间隔 -->
				<!-- The client heartbeat interval -->
				<HBInterval>4000</HBInterval>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>5</msg-threads>
				<!-- 请求超时间隔，单位毫秒，缺省15000毫秒 -->
				<!-- Request timeout interval, the unit is millisecond and default is 15000 milliseconds -->
				<connectorTimeout>20000</connectorTimeout>
				<!-- 请求缓冲区大小，用于缓存已经发给服务器端但是还没收到响应的请求的缓存, 缺省值 1500-->
				<!-- The size of request cache,use to cache the request which send to client but haven't received the response,1500 by default. -->
				<requestCache>1500</requestCache>
				<!-- 消息日志级别，FULL；详细消息日志 SIMPLE：简单消息日志 OFF：不记录消息日志 -->
				<!-- Message log level, FULL: detailed message log ;SIMPLE: a simple message log; OFF:do not record the message log. -->
				<writeMsgLogLevel>OFF</writeMsgLogLevel>
			</params>
			<pipeline factory="com.xxxx.xxx.xxx">
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="linkMonitor" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LinkMonitorHandlerSmpp">
						<job name="link-monitor" runat="link-monitor" interval="1" unit="sec" />
					</handler>
				</main>
				<in>
					<handler name="readTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ClientSocketOneToOneDecoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<!--smpp 要在 msgLogger 之后（确保登录应当被打印）， flux 之前（确保deliver消息不会被统计为应答）。-->
					<!-- smpp must after msgLogger,(Ensure that the log should be printed) 
					     and before flux(Ensure that the deliver messages will not be counted as response)-->
					<handler name="smpp" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.smpp.SmppHandler" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.SmppConnectorPacketCache" />
					<handler name="business" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.BusiEngineHandler" />
					<handler name="remotingDirectCall" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.RemotingDirectCallHamdler" />
					<handler name="callBusi" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.smpp.RemotingDirectCallHandlerSmpp" />
				</in>
				<out>
					<!--必须先 cache 再 encoder -->
					<!-- cache must before encoder -->
					<handler name="business" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.BusiEngineHandler" />
					<handler name="smpp" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.smpp.SmppHandler" />
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.SmppConnectorPacketCache" />
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
				</out>
			</pipeline>
			<jobs-threads>
				<thread name="link-monitor" />
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>

		<adapter name="RemotingUipConnector" apply="remoting" comments="RemotingUipConnector, jobservice/web/bp -> uip">
			<params>
				<!-- ip地址 -->
				<!-- IP address -->
				<ip>127.0.0.1</ip>
				<!-- 端口 -->
				<!-- ip port -->
				<port>19980</port>
				<!-- 本机IP地址，一般在多网卡的主机才需要配置-->
				<!-- machine ip address, General in the multi network card host just need to configure -->
				<localIP></localIP>
				<!-- IO 线程个数 -->
				<!-- the num of io threads -->
				<io-threads>4</io-threads>
				<!-- 协议名称 -->
				<!-- The name of protocol -->
				<protocol>Remoting</protocol>
				<!--心跳模式 1：客户端发心跳 0：服务端发心跳 2：不发心跳 -->
				<!-- heartbeat model. 1:The client send heartbeat, 0:The server send heartbeat, 2: will not send heartbeat -->
				<heartBeatMode>2</heartBeatMode>
				<!--客户端心跳间隔 ，单位毫秒-->
				<!-- The client heartbeat interval ,ms-->
				<HBInterval>4000</HBInterval>
				<!--切包失败超过这个次数，就关闭连接，默认是2，有包头的协议可以调大 -->
				<!-- the maximum Split Error Times,the connection will be closed when the num more than maximum,2 by default,the num can be adjusted to a big if protocol has head-->
				<maxSplitErrorTimes>10</maxSplitErrorTimes>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>5</msg-threads>
				<!-- 请求超时间隔，单位毫秒，缺省15000毫秒 -->
				<!-- Request timeout interval, the unit is millisecond and default is 15000 milliseconds -->
				<connectorTimeout>60000</connectorTimeout>
				<!-- 请求缓冲区大小，用于缓存已经发给服务器端但是还没收到响应的请求的缓存, 缺省值 1500-->
				<!-- The size of request cache,use to cache the request which send to client but haven't received the response,1500 by default. -->
				<requestCache>1500</requestCache>
			</params>
			<pipeline factory="com.xxxx.xxx.xxx">
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="linkMonitor" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LinkMonitorHandler">
						<job name="link-monitor" runat="link-monitor" interval="1" unit="sec" />
					</handler>
				</main>
				<in>
					<handler name="readTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ClientSocketOneToOneDecoder" threadPool="{msg-threads}:5" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.ConnectorPacketCache" />
					<handler name="business" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.BusiEngineHandler" />
					<handler name="notify" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.bpconnector.CallerNotifyHandler" />
				</in>
				<out>
					<!--对于 Remoting 协议，必须先 cache 再 encoder -->
					<!-- For the Remoting protocol,cache must before encoder -->
					<handler name="business" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.BusiEngineHandler" />
					<handler name="connectorCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.connector.ConnectorPacketCache" />
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />
					<handler name="msgLogger" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LoggingHanlder" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
				</out>
			</pipeline>
			<jobs-threads>
				<thread name="link-monitor" />
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>
	</clients>

	<bp-connectors>
		<adapter name="BP" apply="uip" comments="BPProxy">
			<params>
				<!-- 本机IP地址，一般在多网卡的主机才需要配置-->
				<!-- machine ip address, General in the multi network card host just need to configure -->
				<localIP></localIP>
				<!-- IO 线程个数 -->
				<!-- the num of io threads -->
				<io-threads>4</io-threads>
				<!-- 协议 -->
				<!-- protocol -->
				<protocol>Remoting</protocol>
				<!--bp连接检查间隔 -->
				<!-- The time interval of bp connection check -->
				<bpLinkCheckInterval>2</bpLinkCheckInterval>
				<!--切包失败超过这个次数，就关闭连接，默认是2，有包头的协议可以调大 -->
				<!-- the maximum Split Error Times,the connection will be closed when the num more than maximum,2 by default,the num can be adjusted to a big if protocol has head-->
				<maxSplitErrorTimes>10</maxSplitErrorTimes>
				<!--解码器线程池大小,-1则自动获取-->
				<!-- The size of decoder thread pool, -1:automatic acquisition -->
				<msg-threads>16</msg-threads>
				<!-- 请求超时间隔，单位毫秒，缺省15000毫秒 -->
				<!-- Request timeout interval, the unit is millisecond and default is 15000 milliseconds -->
				<connectorTimeout>60000</connectorTimeout>
			</params>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<!--main pipeline -->
				<main>
					<handler name="binder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.Binder" />
					<handler name="linkMonitor" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.LinkMonitorHandler">
						<job name="link-monitor" runat="link-monitor" interval="{bpLinkCheckInterval}:1" unit="sec" />
					</handler>
				</main>
				<!--in pipeline -->
				<in>
					<handler name="readTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="framer" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.frame.SocketFrameDecoder" />
					<handler name="decoder" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.ClientSocketOneToOneDecoder" threadPool="{msg-threads}:20"/>
					<handler name="bpConnectorNbrTrace" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.BpConnectorNbrTraceHandler" />
					<handler name="cache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.bpconnector.RemotingPacketCache" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
					<handler name="dispatcherAndCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.bpconnector.RemotingPacketDispatcher" />
				</in>
				<!--out pipeline -->
				<out>
					<!--必须先 dispatcher 再 encoder -->
					<!-- dispatcher must before encoder -->
					<handler name="dispatcherAndCache" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.bpconnector.RemotingPacketCache" />
					<handler name="encoder" inst-type="single" class="com.ztesoft.zsmart.uip.facilities.io.handler.oneone.SocketOneToOneEncoder" />	
					<handler name="writeTimeOut" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.ReadWriteTimeoutHandler" />
					<handler name="flux" inst-type="adpater-singleton" class="com.ztesoft.zsmart.uip.adapters.handlers.socket.FluxGateway">
						<job name="flowStat-write" runat="flowStat-write" interval="1" unit="sec" />
					</handler>
				</out>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
				<thread name="heartbeat-scan" />
				<thread name="connection-timeout" />
				<thread name="link-monitor" />
				<thread name="flowStat-write" />
			</jobs-threads>
		</adapter>
	</bp-connectors>

	<!-- 所有项目的router-server 都在这里存放，但引用的具体 adapter 由项目定制 -->
	<!-- All items of the router-server here in the store, but the specific adapter referenced by the project customization-->
	<router-server>
		<params>
			<default>Router-BP</default>
		</params>
		<adapter name="Router-RouteId" apply="uip" comments="Router-RouteId">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- 获取路由ID调用的服务名称 -->
				<!-- Obtaining routing ID calls the service name-->
				<getRoutingForUipService>GetRoutingForUipService</getRoutingForUipService>				
			</params>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<in>
					<handler name="firstHandler" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.routing.RouteIdRouterChannelHandler" serviceName="{getRoutingForUipService}:GetRoutingForUipService" />
				</in>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
			</jobs-threads>
			<!--adapter 引用 -->
			<!--adapter reference -->
			<reference>
				<adapter name="bp1" nodeId="agent1"/>
			</reference>
		</adapter>
		<adapter name="Router-Command" apply="uip" comments="Router-Command">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
			</params>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<in>
					<handler name="firstHandler" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.routing.CommandRouterChannelHandler" mode="{balanceMode}:1" />
				</in>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
			</jobs-threads>
			<!--adapter 引用 -->
			<!--adapter reference -->
			<reference>
				<adapter name="bp1" nodeId="agent1"/>
			</reference>
		</adapter>

		<adapter name="Router-BP" apply="uip" comments="Router-BP">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- 负载均衡模式 1：轮询，2：权重，3：按bp最小队列分发，4：按bp空闲线程分发，5： USSD 按会话分发 -->
				<!-- Load balancing mode  1:roll polling,2:by weight,3:distributed by the minimum bp queue,4:distributed by the bp idle thread,5:According to the session distribution by USSD -->
				<balanceMode>1</balanceMode>
			</params>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<in>
					<handler name="firstHandler" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.routing.SimpleRouterChannelHandler" mode="{balanceMode}:1" />
				</in>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
			</jobs-threads>
			<!--adapter 引用 -->
			<!--adapter reference -->
			<reference>
				<adapter name="BP" />
			</reference>
		</adapter>

		<adapter name="Router-USSD" apply="uip" comments="Router-USSD">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- 负载均衡模式 1：轮询，2：权重，3：按bp最小队列分发，4：按bp空闲线程分发，5： USSD 按会话分发 -->
				<!-- Load balancing mode  1:roll polling,2:by weight,3:distributed by the minimum bp queue,4:distributed by the bp idle thread,5:According to the session distribution by USSD -->
				<sessionMode>5</sessionMode>
				<!-- 负载均衡模式 1:轮询，5： USSD 按会话分发 -->
				<!-- Load balancing mode  1:roll polling, 5:According to the session distribution by USSD -->
				<balanceMode>1</balanceMode>
			</params>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<in>
					<handler name="firstHandler" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.routing.SimpleRouterChannelHandler" mode="{sessionMode}:5">
						<field>TargetProxy</field>
					</handler>
					<handler name="secondHandler" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.routing.SessionRouterChannelHandler" mode="{balanceMode}:1" />
				</in>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
			</jobs-threads>
			<!--adapter 引用 -->
			<!--adapter reference -->
			<reference>
				<adapter name="BP" />
			</reference>
		</adapter>
		
		<!--项目化 Router ： 加拿大Roamly项目SMS GW -->
		<!--The project Router:Canada Roamly project SMS GW -->
		<adapter name="Router-ToSmppAgent" apply="uip" comments="router for smpp dispatcher to submit message to smpp agents">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- 协议类型 -->
				<!-- The type of protocol -->
				<protocol>SMPP</protocol>
			</params>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<in>
					<handler name="forwardHandler" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.routing.ForwardRoutingChannelHandler" />
					<handler name="ruleHandler" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.routing.RuleRoutingChannelHandler" />
				</in>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
			</jobs-threads>
			<!--adapter 引用 -->
			<!--adapter reference -->
			<reference>
			</reference>
		</adapter>
		<!--Router:根据messageInstance里面的某个字段-->
		<!--Router:According to a field inside messageInstance -->
		<adapter name="Router-byField" apply="uip" comments="router by router field">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- 协议类型 -->
				<!-- The type of protocol -->
				<protocol>MML</protocol>
			</params>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<in>
					<handler name="ruleHandler" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.routing.RuleRoutingChannelHandler" />
				</in>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
			</jobs-threads>
			<!--adapter 引用 -->
			<!--adapter reference -->
			<reference>
			</reference>
		</adapter>

	</router-server>

	<router-client>
		<params>
			<default>Router-Connectors</default>
		</params>

		<adapter name="Router-Connectors" apply="uip" comments="Router-Connectors">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- 负载均衡模式 1：轮询，2：权重，3：按bp最小队列分发，4：按bp空闲线程分发，5： USSD 按会话分发 -->
				<!-- Load balancing mode  1:roll polling,2:by weight,3:distributed by the minimum bp queue,4:distributed by the bp idle thread,5:According to the session distribution by USSD -->
				<balanceMode>1</balanceMode>
			</params>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<out>
					<handler name="firstHandler" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.routing.SimpleRouterChannelHandler" mode="{balanceMode}:1" />
				</out>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
			</jobs-threads>
			<!--adapter 引用 -->
			<!--adapter reference -->
			<reference>
			</reference>
		</adapter>
		
		<!--项目化 Router ： 印尼 CMS -->
		<!--The project Router:Indonesia CMS -->
		<adapter name="Router-SmartfrenCmsSmpp" apply="uip" comments="用于印尼 CMS 项目发短信的  router">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- 短信异步处理服务，缺省空，可以填 SendCMSAdviceCallBack -->
				<!-- SMS asynchronous processing services,null by default, can be SendCMSAdviceCallBack -->
				<submitAsynService></submitAsynService>
				<!-- 异步发短信时候，短信最大的缓存数量 ， 0 表示无限制，缺省 5000-->
				<!-- The maximum amount of cached messages when sended asynchronous, 0 means unlimited and 5000 by default -->
				<maxBlockedAdvice>5000</maxBlockedAdvice>
				<!-- 负载均衡模式 1：轮询，2：权重，3：按bp最小队列分发，4：按bp空闲线程分发，5： USSD 按会话分发 -->
				<!-- Load balancing mode  1:roll polling,2:by weight,3:distributed by the minimum bp queue,4:distributed by the bp idle thread,5:According to the session distribution by USSD -->
				<balanceMode>1</balanceMode>
				<!--总体流量控制-->
				<!-- The maximum of total caps -->
				<totalCaps>600</totalCaps>
				<!--总流量控制方式0：不控制 1：告警 2：告警并回复过载消息 -->
				<!-- Total caps control mode,0: No control,1: alarm,2: alarm and reply overload message -->
				<totalCapsMode>2</totalCapsMode>
			</params>
			<!--流量相关参数 -->
			<!-- parameters related to caps -->
			<capsControl>
				<totalCaps name="totalFlow" caps="{totalCaps}:600" ctrlMode="{totalCapsMode}:1"></totalCaps>
			</capsControl>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<out>
				    <handler name="preBalanceHandler" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.routing.SimplePreRouterChannelHandler" mode="{balanceMode}:1" />
					<handler name="smppBusiness" inst-type="single" class="com.ztesoft.zsmart.contact.handler.smartfren.cms.SmppRounterHander">
						<job name="flowStat-write" runat="flowStat-write" interval="{flowStatWriteInterval}:1" unit="sec" />
					</handler>
					<handler name="balanceHandler" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.routing.ConextRouterChannelHandler" />
                </out>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
				<thread name="flowStat-write" />
			</jobs-threads>
			<!--adapter 引用 -->
			<!--adapter reference -->
			<reference>
			</reference>
		</adapter>

		<adapter name="Router-ClientByField" apply="uip" comments="Router by field">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<protocol>SMPP</protocol>
				<!-- 短信异步处理服务，缺省空，可以填 SendCMSAdviceCallBack -->
				<!-- SMS asynchronous processing services,null by default, can be SendCMSAdviceCallBack -->
				<submitAsynService></submitAsynService>
				<!-- 异步发短信时候，短信最大的缓存数量 ， 0 表示无限制，缺省 5000-->
				<!-- The maximum amount of cached messages when sended asynchronous, 0 means unlimited and 5000 by default -->
				<maxBlockedAdvice>5000</maxBlockedAdvice>
				<!--总体流量控制-->
				<!-- The maximum of total caps -->
				<totalCaps>600</totalCaps>
				<!--总流量控制方式0：不控制 1：告警 2：告警并回复过载消息 -->
				<!-- Total caps control mode,0: No control,1: alarm,2: alarm and reply overload message -->
				<totalCapsMode>2</totalCapsMode>
			</params>
			<!--流量相关参数 -->
			<!-- parameters related to caps -->
			<capsControl>
				<totalCaps name="totalFlow" caps="{totalCaps}:600" ctrlMode="{totalCapsMode}:1"></totalCaps>
			</capsControl>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<out>
					<handler name="ruleHandler" action="replace" parent="preBalanceHandler" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.routing.RuleRoutingChannelHandler" />
					<handler name="smppBusiness" inst-type="single" class="com.ztesoft.zsmart.contact.handler.smartfren.cms.SmppRounterHander">
						<job name="flowStat-write" runat="flowStat-write" interval="{flowStatWriteInterval}:1" unit="sec" />
					</handler>
					<handler name="balanceHandler" inst-type="single" class="com.ztesoft.zsmart.uip.adapters.handlers.routing.ConextRouterChannelHandler" />
				</out>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
				<thread name="flowStat-write" />
			</jobs-threads>
			<!--adapter 引用 -->
			<!--adapter reference -->
			<reference>
			</reference>
		</adapter>
		
		<!--项目化 Router ： 印尼 CMS -->
		<!--The project Router:Indonesia CMS -->
		<adapter name="Router-SmartfrenCmsMail" apply="uip" comments="用于印尼 CMS 项目发 EMAIL的  router">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- 接口类型：mail 发短信，mms 发彩信 -->
				<!--interface Type: mail:send msg,mms:send multimedia message -->
				<interfaceType>mail</interfaceType>
				<!-- smtp服务器地址，多个服务器使用 ; 隔开 -->
				<!-- The IP address of smtp server,separated by ";" between servers -->
				<smtpHost>10.30.18.230</smtpHost>
				<!-- smtp服务器端口，多个服务器使用 ; 隔开 -->
				<!-- The port of smtp server,separated by ";" between servers -->
				<smtpPort>25</smtpPort>
				<!-- 默认邮件发送人，多个服务器使用 ; 隔开 -->
				<!-- The default sender,separated by ";" between servers -->
				<defaultSender>0027001263@zte.com.cn</defaultSender>				
				<!-- 是否使用smtp验证，多个服务器使用 ; 隔开 -->
				<!-- Whether to use smtp authentication,separated by ";" between servers -->
				<enableAuth>true</enableAuth>
				<!-- smtp登录用户名，多个服务器使用 ; 隔开 -->
				<!-- The login username of smtp server,separated by ";" between servers -->
				<smtpUser>0027001263</smtpUser>
				<!-- smtp登录密码 ，多个服务器使用 ; 隔开-->
				<!-- The login password of smtp server,separated by ";" between servers -->
				<smtpPassword>1234</smtpPassword>
				<!-- 是否使用ssl身份验证 ，多个服务器使用 ; 隔开-->
				<!-- Whether to use ssl authentication,separated by ";" between servers -->
				<enableSSL>false</enableSSL>
				<!-- ssl验证服务器端口，多个服务器使用 ; 隔开 -->
				<!-- The server port of ssl authentication,separated by ";" between servers -->
				<sslPort>25</sslPort>
				<!-- 邮件文本编码方式 -->
				<!-- The encoding type of email text. -->
				<defaultEncoding>utf-8</defaultEncoding>
				<!-- 短信异步处理服务，缺省空，可以填 SendCMSAdviceCallBack -->
				<!-- SMS asynchronous processing services,null by default, can be SendCMSAdviceCallBack -->
				<submitAsynService>SendCMSAdviceCallBack</submitAsynService>
				<!-- 异步发短信时候，短信最大的缓存数量 ， 0 表示无限制，缺省 5000-->
				<!-- The maximum amount of cached messages when sended asynchronous, 0 means unlimited and 5000 by default -->
				<maxBlockedAdvice>1000</maxBlockedAdvice>
				<!-- 工作线程个数，用于加快彩信发送-->
				<!-- The number of job threads which used to speed email seeding -->
				<jobThreads>30</jobThreads>
				<!--写流量文件间隔(s) -->
				<!-- The time interval of write caps file,the unit is second. -->
				<flowStatWriteInterval>1</flowStatWriteInterval>
				<!--最大总流量 -->
				<!-- The maximum of total caps -->
				<totalCaps>180</totalCaps>
				<!--总流量控制方式0：不控制 1：告警 2：告警并回复过载消息 -->
				<!-- Total caps control mode,0: No control,1: alarm,2: alarm and reply overload message -->
				<totalCapsMode>2</totalCapsMode>
				<!-- Socket I/O超时值 -->
				<!-- socket I/O Timeout. -->
				<timeout>60000</timeout>
				<!-- Socket连接超时值 -->
				<!-- socket connection Timeout. -->
				<connectiontimeout>60000</connectiontimeout>
			</params>
			<!--流量相关参数 -->
			<!-- parameters related to caps -->
			<capsControl>
				<totalCaps name="totalFlow" caps="{totalCaps}:500" ctrlMode="{totalCapsMode}:1"></totalCaps>
			</capsControl>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<out>
					<handler name="adviceBusiness" inst-type="single" class="com.ztesoft.zsmart.contact.handler.smartfren.cms.CommonRounterHander">
						<job name="flowStat-write" runat="flowStat-write" interval="{flowStatWriteInterval}:1" unit="sec" />
					</handler>
				</out>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
				<thread name="flowStat-write" />
			</jobs-threads>
			<!--adapter 引用 -->
			<!--adapter reference -->
			<reference>
			</reference>
		</adapter>
		
		<!--项目化 Router ： 印尼 CMS -->
		<!--The project Router:Indonesia CMS -->
		<adapter name="Router-SmartfrenCmsMms" apply="uip" comments="用于印尼 CMS 项目发 MMS 的  router">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- 接口类型：mail 发短信，mms 发彩信 -->
				<!--interface Type: mail:send msg,mms:send multimedia message -->
				<interfaceType>mms</interfaceType>
				<!-- 服务代码 ，多个服务器使用 ; 隔开 -->
				<!-- Service code,separated by ";" between servers -->
				<vasid>zxme</vasid> 
				<!-- SP代码 ，多个服务器使用 ; 隔开 -->
				<!-- SP code,separated by ";" between servers -->
				<vaspid>zxme</vaspid> 
				<!-- 业务代码 ，多个服务器使用 ; 隔开 -->
				<!-- Business code,separated by ";" between servers -->
				<serviceCode>zxme</serviceCode> 
				<!-- 付费方，多个服务器使用 ; 隔开  -->
				<!-- The pay party,separated by ";" between servers -->
				<chargedParty>zxme</chargedParty>
				<!-- 鉴权方式,0表示不鉴权,1表示基本鉴权,2表示摘要鉴权 ，多个服务器使用 ; 隔开 -->
				<!-- Authentication type,0：Noauthentication,1: Basic authentication,2: digest authentication,separated by ";" between servers -->
				<authenticationMode>0</authenticationMode> 
				<!-- 鉴权用户名，多个服务器使用 ; 隔开  -->
				<!-- Authentication user,separated by ";" between servers -->
				<userName>zxme</userName> 
				<!-- 鉴权密码 ，多个服务器使用 ; 隔开 -->
				<!-- Authentication password,separated by ";" between servers -->
				<password>zxme</password> 
				<!-- 彩信中心ID ，多个服务器使用 ; 隔开 -->
				<!-- MMS center ID,separated by ";" between servers -->
				<mmscID>1</mmscID>
				<!-- 发送域名 ，多个服务器使用 ; 隔开 -->
				<!-- MMSC URL,separated by ";" between servers -->
				<mmscURL></mmscURL> 
				<!-- 彩信中心ip地址和端口号 ，多个服务器使用 ; 隔开 -->
				<!-- The IP address and port of MMSC,separated by ";" between servers -->
				<mmscIP>127.0.0.1:7900</mmscIP>
				<!-- 彩信中心代理ip地址和端口号 ，多个服务器使用 ; 隔开 -->
				<!-- The agent IP address and port of MMSC,separated by ";" between servers -->
				<mmscAgentIP>10.42.77.80:7900</mmscAgentIP>
				<!-- 连接属性配置文件路径 -->
				<!-- The path of connection configuration -->
				<connectionConfig>ConnConfig.xml</connectionConfig>
				<!-- 彩信最大大小 -->
				<!-- The maximum size of MMS -->
				<maxMessageSize>100000000</maxMessageSize> 
				<!-- 日志路径,目录须存在,否则不写日志 -->
				<!-- The log directory,will not write log if the directory is not exist -->
				<logPath></logPath> 
				<!-- 日志级别,0表示不产生日志；1表示产生错误日志；3表示产生信息日志；6表示产生完整信息日志 -->
				<!-- Log level,0: no log, 1: error log, 3: info log,6: complete info log -->
				<logLevel>0</logLevel>
				<!-- 日志文件数 -->	
				<!-- The number of log files -->
				<logNum>100</logNum> 
				<!-- 日志生成时间间隔 -->
				<!-- The time interval of log creation -->
				<logInterval>120</logInterval> 
				<!-- 日志文件的大小 -->
				<!-- The size of log file -->
				<logSize>200</logSize> 
				<!-- 消息使用字符集 -->
				<!-- Charset -->
				<charset>UTF-8</charset> 
				<!-- 是否指定IP鉴权 -->
				<!-- Whether to use IP authentication -->
				<defaultLocal>false</defaultLocal> 
				<!-- 鉴权时的指定IP -->
				<!-- The IP address for authentication -->
				<localIP>127.0.0.1</localIP> 
				<!-- 安全 -->
				<!-- Whether to use SSL protocol -->
				<useSSL>true</useSSL> 
				<!-- 状态监听的IP -->
				<!-- The IP address for state listening -->
				<listenIP>10.42.77.80</listenIP> 
				<!-- 监听端口 -->
				<!-- The listening port -->
				<listenPort>8088</listenPort> 
				<!-- 消息接收最大等待队列数 -->
				<!-- The maximum size of the waiting queue for message receiving. -->
				<backLog>50</backLog> 
				<!-- 接收消息默认超时时间 -->
				<!-- The default timeout of message receive -->
				<timeOut>10000</timeOut> 
				<!-- 发送失败重试次数 -->
				<!-- The retry times when sending fail -->
				<reSendCount>1</reSendCount> 
				<!-- 短信异步处理服务，缺省空，可以填 SendCMSAdviceCallBack -->
				<!-- SMS asynchronous processing services,null by default, can be SendCMSAdviceCallBack -->
				<submitAsynService>SendCMSAdviceCallBack</submitAsynService>
				<!-- 异步发短信时候，短信最大的缓存数量 ， 0 表示无限制，缺省 5000-->
				<!-- The maximum amount of cached messages when sended asynchronous, 0 means unlimited and 5000 by default -->
				<maxBlockedAdvice>1000</maxBlockedAdvice>
				<!-- 工作线程个数，用于加快彩信发送-->
				<!-- The number of job threads which used to speed MMS seeding -->
				<jobThreads>30</jobThreads>
				<!--写流量文件间隔(s) -->
				<!-- The time interval of write caps file,the unit is second. -->
				<flowStatWriteInterval>1</flowStatWriteInterval>
				<!--最大总流量 -->
				<!-- The maximum of total caps -->
				<totalCaps>300</totalCaps>
				<!--总流量控制方式0：不控制 1：告警 2：告警并回复过载消息 -->
				<!-- Total caps control mode,0: No control,1: alarm,2: alarm and reply overload message -->
				<totalCapsMode>2</totalCapsMode>
			</params>
			<!--流量相关参数 -->
			<!-- parameters related to caps -->
			<capsControl>
				<totalCaps name="totalFlow" caps="{totalCaps}:500" ctrlMode="{totalCapsMode}:1"></totalCaps>
			</capsControl>
			<!--pipline 构建 -->
			<!--pipline structure -->
			<pipeline factory="com.xxxx.xxx.xxx">
				<out>
					<handler name="adviceBusiness" inst-type="single" class="com.ztesoft.zsmart.contact.handler.smartfren.cms.CommonRounterHander">
						<job name="flowStat-write" runat="flowStat-write" interval="{flowStatWriteInterval}:1" unit="sec" />
					</handler>
				</out>
			</pipeline>
			<!--附属线程 -->
			<!--Additional thread -->
			<jobs-threads>
				<thread name="flowStat-write" />
			</jobs-threads>
			<!--adapter 引用 -->
			<!--adapter reference -->
			<reference>
			</reference>
		</adapter>
	</router-client>

	<jobs>
		<adapter name="advice" apply="bp" implement="com.ztesoft.zsmart.contact.adapter.AdviceScanAdapter" comments="advice scanning job, for smpp to smsc">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- 需要扫描的 advice channel 类型 -->
				<!--Need to scan advice channel types -->
				<adviceChannel>1</adviceChannel>
				<!-- 每次批量扫描的数据量 -->
				<!--The amount of each batch of scan data num -->
				<priorityCount>1=50,2=20</priorityCount>
				<!-- 没有扫描到数据时候，等待下一次扫描的间隔，单位毫秒 -->
				<!--No scanning to the data time, waiting for the next scan interval, unit is milliseconds -->
				<idleInterval>5000</idleInterval>
				<!-- 有数据时候，等待下一次扫描的间隔，单位毫秒 -->
				<!--Data time, waiting for the next scan interval, unit is milliseconds -->
				<busyInterval>100</busyInterval>
				<!-- 等待队列长度 ，队列内请求个数低于这个值才会重新签出请求-->
				<!--the length of Waiting queue, the number is lower than this value will be re checkout requests -->
				<queueSize>50</queueSize>
				<!-- 业务线程个数 -->
				<!-- The number of job threads -->
				<jobThreads>3</jobThreads>
				<!-- 渠道跟适配器的映射关系 -->
				<!-- The mapping relationship with the channel adapter -->
				<adapter>SmsSenderDirectClient</adapter>
				<!-- 发送指令 -->
				<!-- Send command -->
				<command>SUBMIT_SM</command>
				<!-- 批量签入数量 -->
				<!--Batch check in count -->
				<checkInCount>10</checkInCount>
				<!-- 待签入短信最长等待时间，单位毫秒 -->
				<!-- To check in messages the longest waiting time, unit milliseconds -->
				<checkInMaxWait>1000</checkInMaxWait>
				<!-- 是否同步签入短信，缺省 false -->
				<!-- Whether to signing message synchronization,false by default-->
				<synchronizedMode>false</synchronizedMode>
				<!-- 当发生过载时，每次请求的间隔时间，单位毫秒。 -->
				<!--The interval time request when overload, unit milliseconds -->
				<overloadSleep>10</overloadSleep>
				<!-- 当发生过载时，是否需要重新发送 -->
				<!-- Whether to re send when overload-->
				<overloadRedo>false</overloadRedo>
			</params>
		</adapter>
		
		<adapter name="mailAdvice" apply="bp" implement="com.ztesoft.zsmart.contact.adapter.AdviceScan4MailAdapter" comments="advice scanning job, for email and smtp">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- 需要扫描的 advice channel 类型 -->
				<!--Need to scan advice channel types -->
				<adviceChannel>3</adviceChannel>
				<!-- 每次批量扫描的数据量 -->
				<!--The amount of each batch of scan data count -->
				<priorityCount>1=50,2=20</priorityCount>
				<!-- 没有扫描到数据时候，等待下一次扫描的间隔，单位毫秒 -->
				<!--No scanning to the data time, waiting for the next scan interval, unit is milliseconds -->
				<idleInterval>5000</idleInterval>
				<!-- 有数据时候，等待下一次扫描的间隔，单位毫秒 -->
				<!--Data time, waiting for the next scan interval, unit is milliseconds -->
				<busyInterval>100</busyInterval>
				<!-- 等待队列长度 ，队列内请求个数低于这个值才会重新签出请求-->
				<!--the length of Waiting queue, the number is lower than this value will be re checkout requests -->
				<queueSize>50</queueSize>
				<!-- 业务线程个数 -->
				<!-- The number of job threads -->
				<jobThreads>6</jobThreads>
				<!-- 批量签入数量 -->
				<!--Batch check in count -->
				<checkInCount>10</checkInCount>
				<!-- 待签入短信最长等待时间，单位毫秒 -->
				<!-- To check in messages the longest waiting time, unit milliseconds -->
				<checkInMaxWait>1000</checkInMaxWait>
				<!-- 是否同步签入短信，缺省 false -->
				<!-- Whether to signing message synchronization,false by default-->
				<synchronizedMode>false</synchronizedMode>
				<!-- smtp服务器地址 -->
				<!-- The IP address of smtp server -->
				<smtpHost>10.40.11.1</smtpHost>
				<!-- smtp服务器端口 -->
				<!-- The port of smtp server-->
				<smtpPort>25</smtpPort>
				<!-- 默认邮件发送人 -->
				<!-- The default sender -->
				<defaultSender>ccb@zte.com.cn</defaultSender>
				<!-- 邮件文本编码方式 -->
				<!-- The encoding type of email text. -->
				<defaultEncoding>utf-8</defaultEncoding>				
				<!-- 是否使用smtp验证用户名、密码 -->
				<!-- Whether to use smtp authentication -->
				<enableAuth>false</enableAuth>
				<!-- smtp登录用户名 -->
				<!-- The login username of smtp server -->
				<smtpUser>customercare</smtpUser>
				<!-- smtp登录密码 -->
				<!-- The login password of smtp server -->
				<smtpPassword>WinCdma2010</smtpPassword>
				<!-- 是否使用ssl身份验证 -->
				<!-- Whether to use ssl authentication -->
				<enableSSL>false</enableSSL>
				<!-- ssl验证服务器端口 -->
				<!-- The server port of ssl authentication -->
				<sslPort>25</sslPort>
				<!-- Socket I/O超时值 -->
				<!-- socket I/O Timeout. -->
				<timeout>60000</timeout>
				<!-- Socket连接超时值 -->
				<!-- socket connection Timeout. -->
				<connectiontimeout>60000</connectiontimeout>
			</params>
		</adapter>
		
		<adapter name="mmsAdvice" apply="bp" implement="com.ztesoft.zsmart.contact.adapter.AdviceScan4MMSAdapter" comments="advice scanning job, for MMS and MM7">
			<!--adapter 参数 -->
			<!--adapter parameters -->
			<params>
				<!-- 需要扫描的 advice channel 类型 -->
				<!--Need to scan advice channel types -->
				<adviceChannel>9</adviceChannel>
				<!-- 每次批量扫描的数据量 -->
				<!--The amount of each batch of scan data count -->
				<priorityCount>1=50,2=20</priorityCount>
				<!-- 没有扫描到数据时候，等待下一次扫描的间隔，单位毫秒 -->
				<!--No scanning to the data time, waiting for the next scan interval, unit is milliseconds -->
				<idleInterval>5000</idleInterval>
				<!-- 有数据时候，等待下一次扫描的间隔，单位毫秒 -->
				<!--Data time, waiting for the next scan interval, unit is milliseconds -->
				<busyInterval>100</busyInterval>
				<!-- 等待队列长度 ，队列内请求个数低于这个值才会重新签出请求-->
				<!--the length of Waiting queue, the number is lower than this value will be re checkout requests -->
				<queueSize>50</queueSize>
				<!-- 业务线程个数 -->
				<!-- The number of job threads -->
				<jobThreads>6</jobThreads>
				<!-- 批量签入数量 -->
				<!--Batch check in count -->
				<checkInCount>10</checkInCount>
				<!-- 待签入短信最长等待时间，单位毫秒 -->
				<!-- To check in messages the longest waiting time, unit milliseconds -->
				<checkInMaxWait>1000</checkInMaxWait>
				<!-- 是否同步签入短信，缺省 false -->
				<!-- Whether to signing message synchronization,false by default-->
				<synchronizedMode>false</synchronizedMode>
				<!-- 服务代码 -->
				<!-- Service code -->
				<vasid>zxme</vasid> 
				<!-- SP代码 -->
				<!-- SP code -->
				<vaspid>zxme</vaspid> 
				<!-- 业务代码 -->
				<!-- Business code -->
				<serviceCode>zxme</serviceCode> 
				<!-- 付费方 -->
				<!-- The billing party -->
				<chargedParty>zxme</chargedParty>
				<!-- 连接属性配置文件路径 -->
				<!-- The path of connection configuration -->
				<connectionConfig>ConnConfig.xml</connectionConfig>
				<!-- 鉴权方式,0表示不鉴权,1表示基本鉴权,2表示摘要鉴权 -->
				<!-- Authentication type,0：Noauthentication,1: Basic authentication,2: digest authentication -->
				<authenticationMode>0</authenticationMode> 
				<!-- 鉴权用户名 -->
				<!-- Authentication user -->
				<userName>zxme</userName> 
				<!-- 鉴权密码 -->
				<!-- Authentication password -->
				<password>zxme</password> 
				<!-- 彩信最大大小 -->
				<!-- The maximum size of MMS -->
				<maxMessageSize>100000000</maxMessageSize> 
				<!-- 日志路径,目录须存在,否则不写日志 -->
				<!-- The log directory,will not write log if the directory is not exist -->
				<logPath></logPath> 
				<!-- 日志级别,0表示不产生日志；1表示产生错误日志；3表示产生信息日志；6表示产生完整信息日志 -->
				<!-- Log level,0: no log, 1: error log, 3: info log,6: complete info log -->
				<logLevel>0</logLevel>
				<!-- 日志文件数 -->	
				<!-- The number of log files -->
				<logNum>100</logNum> 
				<!-- 日志生成时间间隔 -->
				<!-- The time interval of log creation -->
				<logInterval>120</logInterval> 
				<!-- 日志文件的大小 -->
				<!-- The size of log file -->
				<logSize>200</logSize> 
				<!-- 消息使用字符集 -->
				<!-- Charset -->
				<charset>UTF-8</charset> 
				<!-- 彩信中心ID -->
				<!-- MMS center ID,-->
				<mmscID>1</mmscID>
				<!-- 发送域名 -->
				<!-- MMSC URL -->
				<mmscURL></mmscURL> 
				<!-- 彩信中心ip地址和端口号 -->
				<!-- The IP address and port of MMSC-->
				<mmscIP>127.0.0.1:7900</mmscIP>
				<!-- 彩信中心代理ip地址和端口号 -->
				<!-- The agent IP address and port of MMSC -->
				<mmscAgentIP>10.42.77.80:7900</mmscAgentIP>
				<!-- 是否指定IP鉴权 -->
				<!-- Whether to use IP authentication -->
				<defaultLocal>false</defaultLocal> 
				<!-- 鉴权时的指定IP -->
				<!-- The IP address for authentication -->
				<localIP>127.0.0.1</localIP> 
				<!-- 安全 -->
				<!-- Whether to use SSL protocol -->
				<useSSL>true</useSSL> 
				<!-- 状态监听的IP -->
				<!-- The IP address for state listening -->
				<listenIP>10.42.77.80</listenIP> 
				<!-- 监听端口 -->
				<!-- The listening port -->
				<listenPort>8088</listenPort> 
				<!-- 消息接收最大等待队列数 -->
				<!-- The maximum size of the waiting queue for message receiving. -->
				<backLog>50</backLog> 
				<!-- 接收消息默认超时时间 -->
				<!-- The default timeout of message receive -->
				<timeOut>10000</timeOut> 
				<!-- 发送失败重试次数 -->
				<!-- The retry times when sending fail -->
				<reSendCount>1</reSendCount> 
			</params>
		</adapter>
		
		<adapter name="mailTrack" apply="bp" implement="com.ztesoft.zsmart.contact.adapter.MailTrackAdapter" comments="Mail delivery tracking">
			<params>
				<!-- 需要扫描的mail log文件，转储后的第一个文件 -->
				<!-- Need to scan the mail log file, the first file dump after -->
				<mailLogFile>/var/log/maillog.0</mailLogFile>
				<!-- 监视mailLogFile的间隔，单位毫秒 -->
				<!-- Monitor the mailLogFile interval.unit millisecond -->
				<idleInterval>5000</idleInterval>
				<!-- 队列超时时长，单位秒 -->
				<!-- The timeout of queue,unit second -->
				<timeOut>600</timeOut>
				<!-- 业务线程个数 -->
				<!-- The number of job threads -->
				<jobThreads>6</jobThreads>
				<!-- 查找Queue和Message-id -->
				<!-- regex Queue and Message-id -->
				<regexQueueMessage>: (\w+): message-id=(.+)</regexQueueMessage>
				<!-- 查找Queue和status -->
				<!-- regex Queue and status -->
				<regexQueueStatus>: (\w+): .+status=(\w+)</regexQueueStatus>
				<!-- 查找Requeue -->
				<!-- regex Queue message -->
    			<regexRequeueMessage>: Requeue: (\w+).* to (\w+)</regexRequeueMessage>
				<!--发现错误通知业务的服务-->
				<!--Found error notification service-->
				<adviceFeedBack>AdviceFeedBack</adviceFeedBack>
			</params>
		</adapter>
		
		<adapter name="bounceTrack" apply="bp" implement="com.ztesoft.zsmart.contact.adapter.BounceTracker" comments="Mail delivery tracking">
			<params>				
				<!-- 轮询邮件帐户的间隔，单位毫秒 -->
				<!-- The time interval of roll polling mail account,unit millisecond -->
				<idleInterval>5000</idleInterval>
				<!-- 业务线程个数 -->
				<!-- The number of job threads -->
				<jobThreads>5</jobThreads>
				<!-- URL of the Store. The URL should include the password as well (if needed). Example: "imap://john:password@mailstore.com" -->
				<emailStoreURL>pop3://user1%40htp.com:htp@htp.com</emailStoreURL>				
				<!--发现错误通知业务的服务-->
				<!--Found error notification service-->
				<adviceFeedBack>AdviceFeedBack</adviceFeedBack>
				<!-- 查找原邮件的Message-id -->
				<!-- regex old mail Message-id -->
				<regexMessageId>Message-ID: (&lt;.*@htp\.com&gt;)</regexMessageId>
				<!-- 自动回复的通知STD_CODE，缺省为空则不启用自动回复功能 -->
				<!-- the note std_code of auto reply,default disable auto reply-->
				<autoReply></autoReply>
			</params>
		</adapter>
		
		<adapter name="emailReceiver" apply="bp" implement="com.ztesoft.zsmart.contact.adapter.EmailReceiver" comments="Email Receiver">
			<params>				
				<!-- 轮询邮件帐户的间隔，单位毫秒 -->
				<!-- The time interval of roll polling mail account,unit millisecond -->
				<idleInterval>10000</idleInterval>
				<enableSSL>false</enableSSL>
				<!-- 业务线程个数 -->
				<!-- The number of job threads -->
				<jobThreads>5</jobThreads>
				<!-- URL of the Store. The URL should include the password as well (if needed). Example: "imap://john:password@mailstore.com" -->
				<emailStoreURL>pop3://user1%40htp.com:user1@htp.com</emailStoreURL>
				<!-- 每次轮询收取的邮件个数 -->
				<!-- The number of each polling mail -->
				<fetchCount>10</fetchCount>
				<!-- 收信后调用的处理服务 -->
				<!-- Processing service call after receive mail -->
				<bindService>ReceiveContactCmd</bindService>
			</params>
		</adapter>

		<adapter name="mm7Receiver" apply="bp" 	implement="com.ztesoft.zsmart.contact.adapter.MmsReceiverAdapter" comments="mms receiver">
			<params>
				<!-- 服务代码 -->
				<!-- Service code -->
                <vasid>zxme</vasid> 
                <!-- SP代码 -->
				<!-- SP code -->
                <vaspid>zxme</vaspid> 
                <!-- 业务代码 -->
				<!-- Business code -->
                <serviceCode>zxme</serviceCode> 
                <!-- 付费方 -->
				<!-- The billing party -->
                <chargedParty>zxme</chargedParty>
                <!-- 连接属性配置文件路径 -->
				<!-- The path of connection configuration -->
                <connectionConfig>ConnConfig.xml</connectionConfig>
                <!-- 鉴权方式,0表示不鉴权,1表示基本鉴权,2表示摘要鉴权 -->
				<!-- Authentication type,0：Noauthentication,1: Basic authentication,2: digest authentication -->
                <authenticationMode>0</authenticationMode> 
                <!-- 鉴权用户名 -->
				<!-- Authentication user -->
                <userName>zxme</userName> 
                <!-- 鉴权密码 -->
				<!-- Authentication password -->
                <password>zxme</password> 
                <!-- 彩信最大大小 -->
				<!-- The maximum size of MMS -->
                <maxMessageSize>100000000</maxMessageSize> 
                <!-- 日志路径,目录须存在,否则不写日志 -->
				<!-- The log directory,will not write log if the directory is not exist -->
                <logPath></logPath> 
                <!-- 日志级别,0表示不产生日志；1表示产生错误日志；3表示产生信息日志；6表示产生完整信息日志 -->
				<!-- Log level,0: no log, 1: error log, 3: info log,6: complete info log -->
                <logLevel>0</logLevel>
                <!-- 日志文件数 -->  
				<!-- The number of log files -->
                <logNum>100</logNum> 
                <!-- 日志生成时间间隔 -->
				<!-- The time interval of log creation -->
                <logInterval>120</logInterval> 
                <!-- 日志文件的大小 -->
				<!-- The size of log file -->
                <logSize>200</logSize> 
                <!-- 消息使用字符集 -->
				<!-- Charset -->
                <charset>UTF-8</charset> 
                <!-- 彩信中心ID -->
				<!-- MMS center ID,-->
                <mmscID>1</mmscID>
                <!-- 发送域名 -->
				<!-- MMSC URL -->
                <mmscURL></mmscURL> 
                <!-- 彩信中心ip地址和端口号 -->
				<!-- The IP address and port of MMSC-->
                <mmscIP>127.0.0.1:7900</mmscIP>
                <!-- 彩信中心代理ip地址和端口号 -->
				<!-- The agent IP address and port of MMSC -->
                <mmscAgentIP>10.42.77.80:7900</mmscAgentIP>
                <!-- 是否指定IP鉴权 -->
				<!-- Whether to use IP authentication -->
                <defaultLocal>false</defaultLocal> 
                <!-- 鉴权时的指定IP -->
				<!-- The IP address for authentication -->
                <localIP>127.0.0.1</localIP> 
                <!-- 安全 -->
				<!-- Whether to use SSL protocol -->
                <useSSL>true</useSSL> 
                <!-- 状态监听的IP -->
				<!-- The IP address for state listening -->
                <listenIP>10.42.77.80</listenIP> 
                <!-- 监听端口 -->
				<!-- The listening port -->
                <listenPort>8088</listenPort> 
                <!-- 消息接收最大等待队列数 -->
				<!-- The maximum size of the waiting queue for message receiving. -->
                <backLog>50</backLog> 
                <!-- 接收消息默认超时时间 -->
				<!-- The default timeout of message receive -->
                <timeOut>10000</timeOut> 
                <!-- 发送失败重试次数 -->
				<!-- The retry times when sending fail -->
                <reSendCount>1</reSendCount> 
                <!-- 用于处理彩信回执消息的服务,服务需要处理契约,参数的获取和结果的put -->
				<!-- bind Service,Used in the treatment of MMS receipt message service -->
                <bindService>receiveMMS</bindService>
			</params>
		</adapter>
	</jobs>
	
	<!-- 配置应用启动前或启动后需要执行的处理 , uip-template.xml中配置的handler仅仅起到示范作用,BP应用需要在自己对应的bp{x}.xml中进行覆盖,将配置项定义在uip-template.xml中是无效的-->
	<!-- Treatment needs to be performed before or after the start of the configuration application.Configure uip-template.xml handler just play the exemplary role, the needs of the BP application for coverage in their corresponding bp{x}.xml, configuration item defined in uip-template.xml is invalid-->
	<onStartUp>
	    <!-- 上下文参数,context-param是可选的,供handler使用  -->
		<!-- The context parameter, the context-param is optional, available for handler -->
        <context-param param-name="name1" param-value="value1"/>
        <context-param param-name="name2" param-value="value2"/>
        
		<!-- method:可自动识别是否是static,支持无参数或者以map的形式接收context-params,method的名称必须是唯一的,也就是不要进行方法重载 ,  afterStarted:是否在应用启动后执行 -->
		<!-- method:Can automatically identify whether the static, support parameter free or receiving context-params in the form of map,Method's name must be unique, that is not to carry out method overloading ,afterStarted:Whether to execute after start-->
        <handler class="com.ztesoft.zsmart.bfm.services.BFMService" method="staticInit"  afterStarted="false"/>
		<handler class="com.ztesoft.zsmart.bfm.services.BFMService" method="instanceInit"  afterStarted="true"/>
	</onStartUp>

	<!--The remoting queue configuration -->
	<RemotingCache>
		<default capacity="4000" timeout="60000" />
		<!--  
        <cache name="rechargeCache" capacity="4000" timeout="120000">
            <forRequest command="SM_CHARGE" adapter="VCServer" />
            <forRequest command="DISP PHS ACNTINFO" adapter="MMLServer" />
        </cache>
        <cache name="wsServerCache" capacity="2000" timeout="60000">
            <forRequest command="SimpleService:getGreeting" adapter="WebServiceServer" />
        </cache>
	 -->
	 </RemotingCache>
</uip>